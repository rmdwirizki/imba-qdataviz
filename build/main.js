/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/client.imba");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/imba-router/lib/Route.js":
/*!***********************************************!*\
  !*** ./node_modules/imba-router/lib/Route.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar isWeb = typeof window !== 'undefined';\n\nfunction Route(router,str,parent,options){\n\tthis._parent = parent;\n\tthis._router = router;\n\tthis._options = options || {};\n\tthis._node = this._options.node;\n\tthis._status = 200;\n\tthis.setPath(str);\n};\n\nexports.Route = Route; // export class \nRoute.prototype.raw = function(v){ return this._raw; }\nRoute.prototype.setRaw = function(v){ this._raw = v; return this; };\nRoute.prototype.params = function(v){ return this._params; }\nRoute.prototype.setParams = function(v){ this._params = v; return this; };\nRoute.prototype.__status = {watch: 'statusDidSet',name: 'status'};\nRoute.prototype.status = function(v){ return this._status; }\nRoute.prototype.setStatus = function(v){\n\tvar a = this.status();\n\tif(v != a) { this._status = v; }\n\tif(v != a) { this.statusDidSet && this.statusDidSet(v,a,this.__status) }\n\treturn this;\n};\n\nRoute.prototype.option = function (key){\n\treturn this._options[key];\n};\n\nRoute.prototype.setPath = function (path){\n\tvar self = this;\n\tself._raw = path;\n\tself._groups = [];\n\tself._params = {};\n\tself._cache = {};\n\tpath = path.replace(/\\:(\\w+|\\*)(\\.)?/g,function(m,id,dot) {\n\t\t// what about :id.:format?\n\t\tif (id != '*') { self._groups.push(id) };\n\t\tif (dot) {\n\t\t\treturn \"([^\\/\\#\\.\\?]+)\\.\";\n\t\t} else {\n\t\t\treturn \"([^\\/\\#\\?]+)\";\n\t\t};\n\t});\n\t\n\tpath = '^' + path;\n\tif (self._options.exact && path[path.length - 1] != '$') {\n\t\tpath = path + '(?=[\\#\\?]|$)';\n\t} else {\n\t\t// we only want to match end OR /\n\t\tpath = path + '(?=[\\/\\#\\?]|$)';\n\t};\n\tself._regex = new RegExp(path);\n\treturn self;\n};\n\nRoute.prototype.test = function (url){\n\tvar m, match;\n\turl || (url = this._router.url()); // should include hash?\n\tif (url == this._cache.url) { return this._cache.match };\n\t\n\tlet prefix = '';\n\tlet matcher = this._cache.url = url;\n\tthis._cache.match = null;\n\t\n\tif (this._parent && this._raw[0] != '/') {\n\t\tif (m = this._parent.test(url)) {\n\t\t\tif (url.indexOf(m.path) == 0) {\n\t\t\t\tprefix = m.path + '/';\n\t\t\t\tmatcher = url.slice(m.path.length + 1);\n\t\t\t};\n\t\t};\n\t};\n\t\n\tif (match = matcher.match(this._regex)) {\n\t\tlet path = prefix + match[0];\n\t\tif (path == this._params.path) {\n\t\t\tthis._params.url = url;\n\t\t\treturn this._cache.match = this._params;\n\t\t};\n\t\t\n\t\tthis._params = {path: path,url: url};\n\t\tif (this._groups.length) {\n\t\t\tfor (let i = 0, items = iter$(match), len = items.length, item, name; i < len; i++) {\n\t\t\t\titem = items[i];\n\t\t\t\tif (name = this._groups[i - 1]) {\n\t\t\t\t\tthis._params[name] = item;\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn this._cache.match = this._params;\n\t};\n\t\n\treturn this._cache.match = null;\n};\n\n// should split up the Route types\nRoute.prototype.statusDidSet = function (status,prev){\n\tlet idx = this._router.busy().indexOf(this);\n\tclearTimeout(this._statusTimeout);\n\t\n\tif (status < 200) {\n\t\tif (idx == -1) { this._router.busy().push(this) };\n\t\tthis._statusTimeout = setTimeout(function() { return status = 408; },25000);\n\t} else if (idx >= 0 && status >= 200) {\n\t\tthis._router.busy().splice(idx,1);\n\t\t\n\t\t// immediately to be able to kick of nested routes\n\t\t// is not commit more natural?\n\t\tthis._node && this._node.commit  &&  this._node.commit();\n\t\t// Imba.commit\n\t\tif (this._router.busy().length == 0) {\n\t\t\tImba.emit(this._router,'ready',[this._router]);\n\t\t};\n\t};\n\t\n\treturn this._node && this._node.setFlag  &&  this._node.setFlag('route-status',(\"status-\" + status));\n};\n\nRoute.prototype.load = function (cb){\n\tvar self = this;\n\tself.setStatus(102);\n\t\n\tvar handler = self._handler = function(res) {\n\t\tvar v_;\n\t\tif (handler != self._handler) {\n\t\t\tconsole.log(\"another load has started after this\");\n\t\t\treturn;\n\t\t};\n\t\t\n\t\tself._handler = null;\n\t\treturn (self.setStatus(v_ = ((typeof res=='number'||res instanceof Number)) ? res : 200),v_);\n\t};\n\t\n\tif (cb instanceof Function) {\n\t\tcb = cb(handler);\n\t};\n\t\n\tif (cb && cb.then) {\n\t\tcb.then(handler,handler);\n\t} else {\n\t\thandler(cb);\n\t};\n\treturn self;\n};\n\nRoute.prototype.resolve = function (url){\n\tvar m;\n\turl || (url = this._router.url());\n\tif (this._cache.resolveUrl == url) {\n\t\treturn this._cache.resolved;\n\t};\n\t\n\t// let base = @router.root or ''\n\tlet base = '';\n\tthis._cache.resolveUrl = url; // base + url\n\t\n\tif (this._parent && this._raw[0] != '/') {\n\t\tif (m = this._parent.test()) {\n\t\t\tthis._cache.resolved = base + m.path + '/' + this._raw; // .replace('$','')\n\t\t};\n\t} else {\n\t\t// FIXME what if the url has some unknowns?\n\t\tthis._cache.resolved = base + this._raw; // .replace(/[\\@\\$]/g,'')\n\t};\n\t\n\treturn this._cache.resolved;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba-router/lib/Route.js?");

/***/ }),

/***/ "./node_modules/imba-router/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/imba-router/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function len$(a){\n\treturn a && (a.len instanceof Function ? a.len() : a.length) || 0;\n};\nvar Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar Route = __webpack_require__(/*! ./Route */ \"./node_modules/imba-router/lib/Route.js\").Route;\n\n// check if is web\n\nvar isWeb = typeof window !== 'undefined';\n\nfunction Router(o){\n\tif(o === undefined) o = {};\n\tthis._url = o.url || '';\n\tthis._hash = '';\n\tthis._routes = {};\n\tthis._options = o;\n\tthis._redirects = o.redirects || {};\n\tthis._aliases = o.aliases || {};\n\tthis._busy = [];\n\tthis._root = o.root || '';\n\tthis.setMode(o.mode || 'history');\n\tthis.setup();\n\tthis;\n};\n\nexports.Router = Router; // export class \nRouter._instance = null;\n\nRouter.prototype.__mode = {watch: 'modeDidSet',chainable: true,name: 'mode'};\nRouter.prototype.mode = function(v){ return v !== undefined ? (this.setMode(v),this) : this._mode; }\nRouter.prototype.setMode = function(v){\n\tvar a = this.mode();\n\tif(v != a) { this._mode = v; }\n\tif(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }\n\treturn this;\n};\nRouter.prototype.busy = function(v){ return this._busy; }\nRouter.prototype.setBusy = function(v){ this._busy = v; return this; };\nRouter.prototype.root = function(v){ return this._root; }\nRouter.prototype.setRoot = function(v){ this._root = v; return this; };\n\n// support redirects\nRouter.prototype.option = function (key,value){\n\tif (value == undefined) {\n\t\treturn this._options[key];\n\t} else {\n\t\tthis._options[key] = value;\n\t};\n\treturn this;\n};\n\nRouter.prototype.location = function (){\n\treturn document.location;\n};\n\nRouter.prototype.setup = function (){\n\tvar self = this;\n\tif (isWeb) {\n\t\t// let url = location:pathname\n\t\t// temporary hack to support scrimba out-of-the-box\n\t\tif (!self._root && window.SCRIMBA_ROOT && self.mode() != 'hash') {\n\t\t\tself._root = window.SCRIMBA_ROOT.replace(/\\/$/,'');\n\t\t};\n\t\t\n\t\tlet url = self.path();\n\t\t// if url and @redirects[url]\n\t\tself.history().replaceState({},null,self.normalize(url));\n\t\t\n\t\tself._hash = self.location().hash;\n\t\twindow.addEventListener('hashchange',function(e) {\n\t\t\tself.emit('hashchange',self._hash = self.location().hash);\n\t\t\treturn Imba.commit();\n\t\t});\n\t};\n\treturn self;\n};\n\nRouter.prototype.path = function (){\n\tlet url = this._url || (isWeb ? (((this.mode() == 'hash') ? (this.hash() || '').slice(1) : this.location().pathname)) : '');\n\tif (this._root && url.indexOf(this._root) == 0) {\n\t\turl = url.slice(this._root.length);\n\t};\n\tif (url == '') { url = '/' };\n\turl = this._redirects[url] || url;\n\turl = this._aliases[url] || url;\n\treturn url;\n};\n\nRouter.prototype.url = function (){\n\tvar url = this.path();\n\tif (isWeb && this.mode() != 'hash') {\n\t\turl += this.location().hash;\n\t};\n\treturn url;\n};\n\nRouter.prototype.hash = function (){\n\treturn isWeb ? this.location().hash : '';\n};\n\nRouter.instance = function (){\n\treturn this._instance || (this._instance = new this());\n};\n\nRouter.prototype.history = function (){\n\treturn window.history;\n};\n\nRouter.prototype.match = function (pattern){\n\tvar route = this._routes[pattern] || (this._routes[pattern] = new Route(this,pattern));\n\treturn route.test();\n};\n\nRouter.prototype.go = function (url,state){\n\t// remove hash if we are hash-based and url includes hash\n\tvar self = this;\n\tif(state === undefined) state = {};\n\turl = self._redirects[url] || url;\n\t\n\tself.history().pushState(state,null,self.normalize(url));\n\t// now commit and schedule events afterwards\n\tImba.commit();\n\t\n\tisWeb && self.onReady(function() {\n\t\tlet hash = self.location().hash;\n\t\tif (hash != self._hash) {\n\t\t\treturn self.emit('hashchange',self._hash = hash);\n\t\t};\n\t});\n\treturn self;\n};\n\nRouter.prototype.replace = function (url,state){\n\tif(state === undefined) state = {};\n\turl = this._redirects[url] || url;\n\treturn this.history().replaceState(state,null,this.normalize(url));\n};\n\nRouter.prototype.normalize = function (url){\n\tif (this.mode() == 'hash') {\n\t\turl = (\"#\" + url);\n\t} else if (this.root()) {\n\t\turl = this.root() + url;\n\t};\n\treturn url;\n};\n\nRouter.prototype.onReady = function (cb){\n\tvar self = this;\n\treturn Imba.ticker().add(function() {\n\t\treturn (len$(self._busy) == 0) ? cb(self) : Imba.once(self,'ready',cb);\n\t});\n};\n\nRouter.prototype.emit = function (name){\n\tvar $0 = arguments, i = $0.length;\n\tvar params = new Array(i>1 ? i-1 : 0);\n\twhile(i>1) params[--i - 1] = $0[i];\n\treturn Imba.emit(this,name,params);\n};\nRouter.prototype.on = function (name){\n\tvar Imba_;\n\tvar $0 = arguments, i = $0.length;\n\tvar params = new Array(i>1 ? i-1 : 0);\n\twhile(i>1) params[--i - 1] = $0[i];\n\treturn Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));\n};\nRouter.prototype.once = function (name){\n\tvar Imba_;\n\tvar $0 = arguments, i = $0.length;\n\tvar params = new Array(i>1 ? i-1 : 0);\n\twhile(i>1) params[--i - 1] = $0[i];\n\treturn Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));\n};\nRouter.prototype.un = function (name){\n\tvar Imba_;\n\tvar $0 = arguments, i = $0.length;\n\tvar params = new Array(i>1 ? i-1 : 0);\n\twhile(i>1) params[--i - 1] = $0[i];\n\treturn Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));\n};\n\nconst LinkExtend = {\n\tinject: function(node,opts){\n\t\tlet render = node.render;\n\t\tnode.resolveRoute = this.resolveRoute;\n\t\tnode.beforeRender = this.beforeRender;\n\t\treturn node.ontap || (node.ontap = this.ontap);\n\t},\n\t\n\tbeforeRender: function(){\n\t\tthis.resolveRoute();\n\t\treturn true;\n\t},\n\t\n\tontap: function(e){\n\t\tvar href = this._route.resolve();\n\t\t\n\t\tif (!href) { return };\n\t\t\n\t\tif (this._route.option('sticky')) {\n\t\t\tlet prev = this._route.params().url;\n\t\t\tif (prev && prev.indexOf(href) == 0) {\n\t\t\t\thref = prev;\n\t\t\t};\n\t\t};\n\t\t\n\t\tif ((href[0] != '#' && href[0] != '/')) {\n\t\t\te._responder = null;\n\t\t\te.prevent().stop();\n\t\t\t// need to respect target\n\t\t\treturn window.open(href,'_blank');\n\t\t};\n\t\t\n\t\tif (e.meta() || e.alt()) {\n\t\t\te._responder = null;\n\t\t\te.prevent().stop();\n\t\t\treturn window.open(this.router().root() + href,'_blank');\n\t\t};\n\t\t\n\t\te.prevent().stop();\n\t\treturn this.router().go(href,{});\n\t},\n\t\n\tresolveRoute: function(){\n\t\tlet match = this._route.test();\n\t\tthis.setAttribute('href',this.router().root() + this._route.resolve());\n\t\treturn this.flagIf('active',this._route.test());\n\t}\n};\n\n\nconst RoutedExtend = {\n\t\n\tinject: function(node){\n\t\tnode._params = {};\n\t\tnode.resolveRoute = this.resolveRoute;\n\t\tnode.beforeRender = this.beforeRender;\n\t\treturn node.detachFromParent();\n\t},\n\t\n\tbeforeRender: function(){\n\t\tthis.resolveRoute();\n\t\tif (!this._params._active) { return false };\n\t\t\n\t\tlet status = this._route.status();\n\t\t\n\t\tif (this[(\"render\" + status)]) {\n\t\t\tthis[(\"render\" + status)]();\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tif (status >= 200) {\n\t\t\treturn true;\n\t\t};\n\t\t\n\t\treturn false;\n\t},\n\t\n\tresolveRoute: function(next){\n\t\tvar self = this;\n\t\tlet prev = self._params;\n\t\tlet match = self._route.test();\n\t\t\n\t\tif (match) {\n\t\t\tif (match != prev) {\n\t\t\t\tself.setParams(match);\n\t\t\t\tif (self.load) {\n\t\t\t\t\tself.route().load(function() { return self.load(self.params()); });\n\t\t\t\t};\n\t\t\t};\n\t\t\t// call method every time if the actual url has changed - even if match is the same?\n\t\t\t\n\t\t\tif (!match._active) {\n\t\t\t\tmatch._active = true;\n\t\t\t\t// should happen after load?\n\t\t\t\treturn self.attachToParent();\n\t\t\t};\n\t\t} else if (prev._active) {\n\t\t\tprev._active = false;\n\t\t\treturn self.detachFromParent();\n\t\t};\n\t}\n};\n\n\nImba.extendTag('element', function(tag){\n\ttag.prototype.__params = {watch: 'paramsDidSet',name: 'params'};\n\ttag.prototype.params = function(v){ return this._params; }\n\ttag.prototype.setParams = function(v){\n\t\tvar a = this.params();\n\t\tif(v != a) { this._params = v; }\n\t\tif(v != a) { this.paramsDidSet && this.paramsDidSet(v,a,this.__params) }\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.route = function (){\n\t\treturn this._route;\n\t};\n\t\n\ttag.prototype.setRoute = function (path,mods){\n\t\tlet prev = this._route;\n\t\t\n\t\tif (!prev) {\n\t\t\tpath = String(path);\n\t\t\tlet par = (path[0] != '/') ? this.getParentRoute() : null;\n\t\t\tlet opts = mods || {};\n\t\t\topts.node = this;\n\t\t\tthis._route = new Route(this.router(),path,par,opts);\n\t\t\tif (opts.link) {\n\t\t\t\tLinkExtend.inject(this,opts);\n\t\t\t} else {\n\t\t\t\tRoutedExtend.inject(this);\n\t\t\t};\n\t\t} else if (String(path) != prev._raw) {\n\t\t\tprev.setPath(String(path));\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setRouteTo = function (path,mods){\n\t\tif (this._route) {\n\t\t\treturn this.setRoute(path);\n\t\t} else {\n\t\t\tmods || (mods = {});\n\t\t\tmods.link = true;\n\t\t\treturn this.setRoute(path,mods);\n\t\t};\n\t};\n\t\n\t// for server\n\ttag.prototype.setRouterUrl = function (url){\n\t\tthis._router || (this._router = new Router(url));\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setRouterRoot = function (url){\n\t\tthis.router().setRoot(url);\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.getParentRoute = function (){\n\t\tvar route = null;\n\t\tvar par = this._owner_;\n\t\twhile (par){\n\t\t\tif (par._route) {\n\t\t\t\treturn par._route;\n\t\t\t};\n\t\t\tpar = par._owner_;\n\t\t};\n\t\treturn null;\n\t};\n\t\n\ttag.prototype.setRouter = function (router){\n\t\tthis._router = router;\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.router = function (){\n\t\treturn this._router || (this._router = (this._owner_ && this._owner_.router() || new Router()));\n\t\t// isWeb ? Router.instance : (@router or (@owner_ ? @owner_.router : (@router ||= Router.new)))\n\t};\n});\n\n\n//# sourceURL=webpack:///./node_modules/imba-router/lib/index.js?");

/***/ }),

/***/ "./node_modules/imba/imba.imba":
/*!*************************************!*\
  !*** ./node_modules/imba/imba.imba ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/imba/index.imba */ \"./node_modules/imba/src/imba/index.imba\");\n\n\n//# sourceURL=webpack:///./node_modules/imba/imba.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/event-manager.imba":
/*!***********************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/event-manager.imba ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n__webpack_require__(/*! ./pointer */ \"./node_modules/imba/src/imba/dom/pointer.imba\");\n\nvar native$ = [\n\t'keydown','keyup','keypress',\n\t'textInput','input','change','submit',\n\t'focusin','focusout','focus','blur',\n\t'contextmenu','selectstart','dblclick',\n\t'mousewheel','wheel','scroll',\n\t'beforecopy','copy','beforepaste','paste','beforecut','cut',\n\t'dragstart','drag','dragend','dragenter','dragover','dragleave','dragexit','drop',\n\t'mouseup','mousedown','mouseenter','mouseleave','mouseout','mouseover','mousemove'\n];\n\n/*\n\nManager for listening to and delegating events in Imba. A single instance\nis always created by Imba (as `Imba.Events`), which handles and delegates all\nevents at the very root of the document. Imba does not capture all events\nby default, so if you want to make sure exotic or custom DOMEvents are delegated\nin Imba you will need to register them in `Imba.Events.register(myCustomEventName)`\n\n@iname manager\n\n*/\n\nImba.EventManager = function EventManager(node,pars){\n\tvar self = this;\n\tif(!pars||pars.constructor !== Object) pars = {};\n\tvar events = pars.events !== undefined ? pars.events : [];\n\tself._shimFocusEvents = true && window.netscape && node.onfocusin === undefined;\n\tself.setRoot(node);\n\tself.setListeners([]);\n\tself.setDelegators({});\n\tself.setDelegator(function(e) {\n\t\tself.delegate(e);\n\t\treturn true;\n\t});\n\t\n\tfor (let i = 0, items = iter$(events), len = items.length; i < len; i++) {\n\t\tself.register(items[i]);\n\t};\n\t\n\treturn self;\n};\n\nImba.EventManager.prototype.root = function(v){ return this._root; }\nImba.EventManager.prototype.setRoot = function(v){ this._root = v; return this; };\nImba.EventManager.prototype.count = function(v){ return this._count; }\nImba.EventManager.prototype.setCount = function(v){ this._count = v; return this; };\nImba.EventManager.prototype.__enabled = {'default': false,watch: 'enabledDidSet',name: 'enabled'};\nImba.EventManager.prototype.enabled = function(v){ return this._enabled; }\nImba.EventManager.prototype.setEnabled = function(v){\n\tvar a = this.enabled();\n\tif(v != a) { this._enabled = v; }\n\tif(v != a) { this.enabledDidSet && this.enabledDidSet(v,a,this.__enabled) }\n\treturn this;\n}\nImba.EventManager.prototype._enabled = false;\nImba.EventManager.prototype.listeners = function(v){ return this._listeners; }\nImba.EventManager.prototype.setListeners = function(v){ this._listeners = v; return this; };\nImba.EventManager.prototype.delegators = function(v){ return this._delegators; }\nImba.EventManager.prototype.setDelegators = function(v){ this._delegators = v; return this; };\nImba.EventManager.prototype.delegator = function(v){ return this._delegator; }\nImba.EventManager.prototype.setDelegator = function(v){ this._delegator = v; return this; };\n\nvar initialBind = [];\n\nImba.EventManager.prototype.enabledDidSet = function (bool){\n\tbool ? this.onenable() : this.ondisable();\n\treturn this;\n};\n\nImba.EventManager.bind = function (name){\n\tif (Imba.Events) {\n\t\treturn Imba.Events.autoregister(name);\n\t} else if (initialBind.indexOf(name) == -1 && native$.indexOf(name) >= 0) {\n\t\treturn initialBind.push(name);\n\t};\n};\n\nImba.EventManager.activate = function (){\n\tvar Imba_;\n\tif (Imba.Events) { return Imba.Events };\n\tif (false) {};\n\t\n\tImba.POINTER || (Imba.POINTER = new Imba.Pointer());\n\tImba.Events = new Imba.EventManager(Imba.document(),{events: []});\n\t\n\tvar hasTouchEvents = window && window.ontouchstart !== undefined;\n\t\n\tif (hasTouchEvents) {\n\t\tImba.Events.listen('touchstart',function(e) {\n\t\t\treturn Imba.Touch.ontouchstart(e);\n\t\t});\n\t\t\n\t\tImba.Events.listen('touchmove',function(e) {\n\t\t\treturn Imba.Touch.ontouchmove(e);\n\t\t});\n\t\t\n\t\tImba.Events.listen('touchend',function(e) {\n\t\t\treturn Imba.Touch.ontouchend(e);\n\t\t});\n\t\t\n\t\tImba.Events.listen('touchcancel',function(e) {\n\t\t\treturn Imba.Touch.ontouchcancel(e);\n\t\t});\n\t};\n\t\n\tImba.Events.register('click',function(e) {\n\t\t// Only for main mousebutton, no?\n\t\tif ((e.timeStamp - Imba.Touch.LastTimestamp) > Imba.Touch.TapTimeout) {\n\t\t\te._imbaSimulatedTap = true;\n\t\t\tvar tap = new Imba.Event(e);\n\t\t\ttap.setType('tap');\n\t\t\ttap.process();\n\t\t\tif (tap._responder) {\n\t\t\t\treturn e.preventDefault();\n\t\t\t};\n\t\t};\n\t\t// delegate the real click event\n\t\treturn Imba.Events.delegate(e);\n\t});\n\t\n\tImba.Events.listen('mousedown',function(e) {\n\t\tif ((e.timeStamp - Imba.Touch.LastTimestamp) > Imba.Touch.TapTimeout) {\n\t\t\tif (Imba.POINTER) { return Imba.POINTER.update(e).process() };\n\t\t};\n\t});\n\t\n\tImba.Events.listen('mouseup',function(e) {\n\t\tif ((e.timeStamp - Imba.Touch.LastTimestamp) > Imba.Touch.TapTimeout) {\n\t\t\tif (Imba.POINTER) { return Imba.POINTER.update(e).process() };\n\t\t};\n\t});\n\t\n\tImba.Events.register(['mousedown','mouseup']);\n\tImba.Events.register(initialBind);\n\tImba.Events.setEnabled(true);\n\treturn Imba.Events;\n};\n\n\n/*\n\n\tTell the current EventManager to intercept and handle event of a certain name.\n\tBy default, Imba.Events will register interceptors for: *keydown*, *keyup*, \n\t*keypress*, *textInput*, *input*, *change*, *submit*, *focusin*, *focusout*, \n\t*blur*, *contextmenu*, *dblclick*, *mousewheel*, *wheel*\n\n\t*/\n\nImba.EventManager.prototype.register = function (name,handler){\n\tif(handler === undefined) handler = true;\n\tif (name instanceof Array) {\n\t\tfor (let i = 0, items = iter$(name), len = items.length; i < len; i++) {\n\t\t\tthis.register(items[i],handler);\n\t\t};\n\t\treturn this;\n\t};\n\t\n\tif (this.delegators()[name]) { return this };\n\t\n\t// console.log(\"register for event {name}\")\n\tvar fn = this.delegators()[name] = (handler instanceof Function) ? handler : this.delegator();\n\tif (this.enabled()) { return this.root().addEventListener(name,fn,true) };\n};\n\nImba.EventManager.prototype.autoregister = function (name){\n\tif (native$.indexOf(name) == -1) { return this };\n\treturn this.register(name);\n};\n\nImba.EventManager.prototype.listen = function (name,handler,capture){\n\tif(capture === undefined) capture = true;\n\tthis.listeners().push([name,handler,capture]);\n\tif (this.enabled()) { this.root().addEventListener(name,handler,capture) };\n\treturn this;\n};\n\nImba.EventManager.prototype.delegate = function (e){\n\tvar event = Imba.Event.wrap(e);\n\tevent.process();\n\tif (this._shimFocusEvents) {\n\t\tif (e.type == 'focus') {\n\t\t\tImba.Event.wrap(e).setType('focusin').process();\n\t\t} else if (e.type == 'blur') {\n\t\t\tImba.Event.wrap(e).setType('focusout').process();\n\t\t};\n\t};\n\treturn this;\n};\n\n/*\n\n\tCreate a new Imba.Event\n\n\t*/\n\nImba.EventManager.prototype.create = function (type,target,pars){\n\tif(!pars||pars.constructor !== Object) pars = {};\n\tvar data = pars.data !== undefined ? pars.data : null;\n\tvar source = pars.source !== undefined ? pars.source : null;\n\tvar event = Imba.Event.wrap({type: type,target: target});\n\tif (data) { (event.setData(data),data) };\n\tif (source) { (event.setSource(source),source) };\n\treturn event;\n};\n\n/*\n\n\tTrigger / process an Imba.Event.\n\n\t*/\n\nImba.EventManager.prototype.trigger = function (){\n\treturn this.create.apply(this,arguments).process();\n};\n\nImba.EventManager.prototype.onenable = function (){\n\tfor (let o = this.delegators(), handler, i = 0, keys = Object.keys(o), l = keys.length, name; i < l; i++){\n\t\tname = keys[i];handler = o[name];this.root().addEventListener(name,handler,true);\n\t};\n\t\n\tfor (let i = 0, items = iter$(this.listeners()), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tthis.root().addEventListener(item[0],item[1],item[2]);\n\t};\n\t\n\twindow.addEventListener('hashchange',Imba.commit);\n\twindow.addEventListener('popstate',Imba.commit);\n\treturn this;\n};\n\nImba.EventManager.prototype.ondisable = function (){\n\tfor (let o = this.delegators(), handler, i = 0, keys = Object.keys(o), l = keys.length, name; i < l; i++){\n\t\tname = keys[i];handler = o[name];this.root().removeEventListener(name,handler,true);\n\t};\n\t\n\tfor (let i = 0, items = iter$(this.listeners()), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tthis.root().removeEventListener(item[0],item[1],item[2]);\n\t};\n\t\n\twindow.removeEventListener('hashchange',Imba.commit);\n\twindow.removeEventListener('popstate',Imba.commit);\n\treturn this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/event-manager.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/event.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/event.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nvar keyCodes = {\n\tesc: 27,\n\ttab: 9,\n\tenter: 13,\n\tspace: 32,\n\tup: 38,\n\tdown: 40\n};\n\nvar el = Imba.Tag.prototype;\nel.stopModifier = function (e){\n\treturn e.stop() || true;\n};\nel.preventModifier = function (e){\n\treturn e.prevent() || true;\n};\nel.silenceModifier = function (e){\n\treturn e.silence() || true;\n};\nel.bubbleModifier = function (e){\n\treturn e.bubble(true) || true;\n};\nel.ctrlModifier = function (e){\n\treturn e.event().ctrlKey == true;\n};\nel.altModifier = function (e){\n\treturn e.event().altKey == true;\n};\nel.shiftModifier = function (e){\n\treturn e.event().shiftKey == true;\n};\nel.metaModifier = function (e){\n\treturn e.event().metaKey == true;\n};\nel.keyModifier = function (key,e){\n\treturn e.keyCode() ? ((e.keyCode() == key)) : true;\n};\nel.delModifier = function (e){\n\treturn e.keyCode() ? ((e.keyCode() == 8 || e.keyCode() == 46)) : true;\n};\nel.selfModifier = function (e){\n\treturn e.event().target == this._dom;\n};\nel.leftModifier = function (e){\n\treturn (e.button() != undefined) ? ((e.button() === 0)) : el.keyModifier(37,e);\n};\nel.rightModifier = function (e){\n\treturn (e.button() != undefined) ? ((e.button() === 2)) : el.keyModifier(39,e);\n};\nel.middleModifier = function (e){\n\treturn (e.button() != undefined) ? ((e.button() === 1)) : true;\n};\n\nel.getHandler = function (str,event){\n\tif (this[str]) { return this };\n};\n\n/*\nImba handles all events in the dom through a single manager,\nlistening at the root of your document. If Imba finds a tag\nthat listens to a certain event, the event will be wrapped \nin an `Imba.Event`, which normalizes some of the quirks and \nbrowser differences.\n\n@iname event\n*/\n\nImba.Event = function Event(e){\n\tthis.setEvent(e);\n\tthis._bubble = true;\n};\n\n/* reference to the native event */\n\nImba.Event.prototype.event = function(v){ return this._event; }\nImba.Event.prototype.setEvent = function(v){ this._event = v; return this; };\n\nImba.Event.prototype.prefix = function(v){ return this._prefix; }\nImba.Event.prototype.setPrefix = function(v){ this._prefix = v; return this; };\n\nImba.Event.prototype.source = function(v){ return this._source; }\nImba.Event.prototype.setSource = function(v){ this._source = v; return this; };\n\nImba.Event.prototype.data = function(v){ return this._data; }\nImba.Event.prototype.setData = function(v){ this._data = v; return this; };\n\nImba.Event.prototype.responder = function(v){ return this._responder; }\nImba.Event.prototype.setResponder = function(v){ this._responder = v; return this; };\n\nImba.Event.wrap = function (e){\n\treturn new this(e);\n};\n\nImba.Event.prototype.setType = function (type){\n\tthis._type = type;\n\tthis;\n\treturn this;\n};\n\n/*\n\t@return {String} The name of the event (case-insensitive)\n\t*/\n\nImba.Event.prototype.type = function (){\n\treturn this._type || this.event().type;\n};\nImba.Event.prototype.native = function (){\n\treturn this._event;\n};\n\nImba.Event.prototype.name = function (){\n\treturn this._name || (this._name = this.type().toLowerCase().replace(/\\:/g,''));\n};\n\n// mimc getset\nImba.Event.prototype.bubble = function (v){\n\tif (v != undefined) {\n\t\tthis.setBubble(v);\n\t\treturn this;\n\t};\n\treturn this._bubble;\n};\n\nImba.Event.prototype.setBubble = function (v){\n\tthis._bubble = v;\n\treturn this;\n\treturn this;\n};\n\n/*\n\tPrevents further propagation of the current event.\n\t@return {self}\n\t*/\n\nImba.Event.prototype.stop = function (){\n\tthis.setBubble(false);\n\treturn this;\n};\n\nImba.Event.prototype.stopPropagation = function (){\n\treturn this.stop();\n};\nImba.Event.prototype.halt = function (){\n\treturn this.stop();\n};\n\n// migrate from cancel to prevent\nImba.Event.prototype.prevent = function (){\n\tif (this.event().preventDefault) {\n\t\tthis.event().preventDefault();\n\t} else {\n\t\tthis.event().defaultPrevented = true;\n\t};\n\tthis.defaultPrevented = true;\n\treturn this;\n};\n\nImba.Event.prototype.preventDefault = function (){\n\tconsole.warn(\"Event#preventDefault is deprecated - use Event#prevent\");\n\treturn this.prevent();\n};\n\n/*\n\tIndicates whether or not event.cancel has been called.\n\n\t@return {Boolean}\n\t*/\n\nImba.Event.prototype.isPrevented = function (){\n\treturn this.event() && this.event().defaultPrevented || this._cancel;\n};\n\n/*\n\tCancel the event (if cancelable). In the case of native events it\n\twill call `preventDefault` on the wrapped event object.\n\t@return {self}\n\t*/\n\nImba.Event.prototype.cancel = function (){\n\tconsole.warn(\"Event#cancel is deprecated - use Event#prevent\");\n\treturn this.prevent();\n};\n\nImba.Event.prototype.silence = function (){\n\tthis._silenced = true;\n\treturn this;\n};\n\nImba.Event.prototype.isSilenced = function (){\n\treturn !!this._silenced;\n};\n\n/*\n\tA reference to the initial target of the event.\n\t*/\n\nImba.Event.prototype.target = function (){\n\treturn Imba.getTagForDom(this.event()._target || this.event().target);\n};\n\n/*\n\tA reference to the object responding to the event.\n\t*/\n\nImba.Event.prototype.responder = function (){\n\treturn this._responder;\n};\n\n/*\n\tRedirect the event to new target\n\t*/\n\nImba.Event.prototype.redirect = function (node){\n\tthis._redirect = node;\n\treturn this;\n};\n\nImba.Event.prototype.processHandlers = function (node,handlers){\n\tlet i = 1;\n\tlet l = handlers.length;\n\tlet bubble = this._bubble;\n\tlet state = handlers.state || (handlers.state = {});\n\tlet result;\n\t\n\tif (bubble) {\n\t\tthis._bubble = 1;\n\t};\n\t\n\twhile (i < l){\n\t\tlet isMod = false;\n\t\tlet handler = handlers[i++];\n\t\tlet params = null;\n\t\tlet context = node;\n\t\t\n\t\tif (handler instanceof Array) {\n\t\t\tparams = handler.slice(1);\n\t\t\thandler = handler[0];\n\t\t};\n\t\t\n\t\tif (typeof handler == 'string') {\n\t\t\tif (keyCodes[handler]) {\n\t\t\t\tparams = [keyCodes[handler]];\n\t\t\t\thandler = 'key';\n\t\t\t};\n\t\t\t\n\t\t\tlet mod = handler + 'Modifier';\n\t\t\t\n\t\t\tif (node[mod]) {\n\t\t\t\tisMod = true;\n\t\t\t\tparams = (params || []).concat([this,state]);\n\t\t\t\thandler = node[mod];\n\t\t\t};\n\t\t};\n\t\t\n\t\t// if it is still a string - call getHandler on\n\t\t// ancestor of node to see if we get a handler for this name\n\t\tif (typeof handler == 'string') {\n\t\t\tlet el = node;\n\t\t\tlet fn = null;\n\t\t\tlet ctx = state.context;\n\t\t\t\n\t\t\tif (ctx) {\n\t\t\t\tif (ctx.getHandler instanceof Function) {\n\t\t\t\t\tctx = ctx.getHandler(handler,this);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif (ctx[handler] instanceof Function) {\n\t\t\t\t\thandler = fn = ctx[handler];\n\t\t\t\t\tcontext = ctx;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (!fn) {\n\t\t\t\tconsole.warn((\"event \" + this.type() + \": could not find '\" + handler + \"' in context\"),ctx);\n\t\t\t};\n\t\t\t\n\t\t\t// while el and (!fn or !(fn isa Function))\n\t\t\t// \tif fn = el.getHandler(handler)\n\t\t\t// \t\tif fn[handler] isa Function\n\t\t\t// \t\t\thandler = fn[handler]\n\t\t\t// \t\t\tcontext = fn\n\t\t\t// \t\telif fn isa Function\n\t\t\t// \t\t\thandler = fn\n\t\t\t// \t\t\tcontext = el\n\t\t\t// \telse\n\t\t\t// \t\tel = el.parent\n\t\t};\n\t\t\n\t\tif (handler instanceof Function) {\n\t\t\t// what if we actually call stop inside function?\n\t\t\t// do we still want to continue the chain?\n\t\t\tlet res = handler.apply(context,params || [this]);\n\t\t\t\n\t\t\tif (!isMod) {\n\t\t\t\tthis._responder || (this._responder = node);\n\t\t\t};\n\t\t\t\n\t\t\tif (res == false) {\n\t\t\t\t// console.log \"returned false - breaking\"\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\t\n\t\t\tif (res && !this._silenced && (res.then instanceof Function)) {\n\t\t\t\tres.then(Imba.commit);\n\t\t\t};\n\t\t};\n\t};\n\t\n\t// if we havent stopped or dealt with bubble while handling\n\tif (this._bubble === 1) {\n\t\tthis._bubble = bubble;\n\t};\n\t\n\treturn null;\n};\n\nImba.Event.prototype.process = function (){\n\tvar name = this.name();\n\tvar meth = (\"on\" + (this._prefix || '') + name);\n\tvar args = null;\n\tvar domtarget = this.event()._target || this.event().target;\n\tvar domnode = domtarget._responder || domtarget;\n\t// @todo need to stop infinite redirect-rules here\n\tvar result;\n\tvar handlers;\n\t\n\twhile (domnode){\n\t\tthis._redirect = null;\n\t\tlet node = domnode._dom ? domnode : domnode._tag;\n\t\t\n\t\tif (node) {\n\t\t\tif (handlers = node._on_) {\n\t\t\t\tfor (let i = 0, items = iter$(handlers), len = items.length, handler; i < len; i++) {\n\t\t\t\t\thandler = items[i];\n\t\t\t\t\tif (!handler) { continue; };\n\t\t\t\t\tlet hname = handler[0];\n\t\t\t\t\tif (name == handler[0] && this.bubble()) {\n\t\t\t\t\t\tthis.processHandlers(node,handler);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tif (!(this.bubble())) { break; };\n\t\t\t};\n\t\t\t\n\t\t\tif (this.bubble() && (node[meth] instanceof Function)) {\n\t\t\t\tthis._responder || (this._responder = node);\n\t\t\t\tthis._silenced = false;\n\t\t\t\tresult = args ? node[meth].apply(node,args) : node[meth](this,this.data());\n\t\t\t};\n\t\t\t\n\t\t\tif (node.onevent) {\n\t\t\t\tnode.onevent(this);\n\t\t\t};\n\t\t};\n\t\t\n\t\t// add node.nextEventResponder as a separate method here?\n\t\tif (!(this.bubble() && (domnode = (this._redirect || (node ? node.parent() : domnode.parentNode))))) {\n\t\t\tbreak;\n\t\t};\n\t};\n\t\n\tthis.processed();\n\t\n\t// if a handler returns a promise, notify schedulers\n\t// about this after promise has finished processing\n\tif (result && (result.then instanceof Function)) {\n\t\tresult.then(this.processed.bind(this));\n\t};\n\treturn this;\n};\n\n\nImba.Event.prototype.processed = function (){\n\tif (!this._silenced && this._responder) {\n\t\tImba.emit(Imba,'event',[this]);\n\t\tImba.commit(this.event());\n\t};\n\treturn this;\n};\n\n/*\n\tReturn the x/left coordinate of the mouse / pointer for this event\n\t@return {Number} x coordinate of mouse / pointer for event\n\t*/\n\nImba.Event.prototype.x = function (){\n\treturn this.native().x;\n};\n\n/*\n\tReturn the y/top coordinate of the mouse / pointer for this event\n\t@return {Number} y coordinate of mouse / pointer for event\n\t*/\n\nImba.Event.prototype.y = function (){\n\treturn this.native().y;\n};\n\nImba.Event.prototype.button = function (){\n\treturn this.native().button;\n};\nImba.Event.prototype.keyCode = function (){\n\treturn this.native().keyCode;\n};\nImba.Event.prototype.ctrl = function (){\n\treturn this.native().ctrlKey;\n};\nImba.Event.prototype.alt = function (){\n\treturn this.native().altKey;\n};\nImba.Event.prototype.shift = function (){\n\treturn this.native().shiftKey;\n};\nImba.Event.prototype.meta = function (){\n\treturn this.native().metaKey;\n};\nImba.Event.prototype.key = function (){\n\treturn this.native().key;\n};\n\n/*\n\tReturns a Number representing a system and implementation\n\tdependent numeric code identifying the unmodified value of the\n\tpressed key; this is usually the same as keyCode.\n\n\tFor mouse-events, the returned value indicates which button was\n\tpressed on the mouse to trigger the event.\n\n\t@return {Number}\n\t*/\n\nImba.Event.prototype.which = function (){\n\treturn this.event().which;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/event.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/html.imba":
/*!**************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/html.imba ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.defineTag('fragment', 'element', function(tag){\n\ttag.createNode = function (){\n\t\treturn Imba.document().createDocumentFragment();\n\t};\n});\n\nImba.extendTag('html', function(tag){\n\ttag.prototype.parent = function (){\n\t\treturn null;\n\t};\n});\n\nImba.extendTag('canvas', function(tag){\n\ttag.prototype.context = function (type){\n\t\tif(type === undefined) type = '2d';\n\t\treturn this.dom().getContext(type);\n\t};\n});\n\nfunction DataProxy(node,path,args){\n\tthis._node = node;\n\tthis._path = path;\n\tthis._args = args;\n\tif (this._args) { this._setter = Imba.toSetter(this._path) };\n};\n\nDataProxy.bind = function (receiver,data,path,args){\n\tlet proxy = receiver._data || (receiver._data = new this(receiver,path,args));\n\tproxy.bind(data,path,args);\n\treturn receiver;\n};\n\nDataProxy.prototype.bind = function (data,key,args){\n\tif (data != this._data) {\n\t\tthis._data = data;\n\t};\n\treturn this;\n};\n\nDataProxy.prototype.getFormValue = function (){\n\treturn this._setter ? this._data[this._path]() : this._data[this._path];\n};\n\nDataProxy.prototype.setFormValue = function (value){\n\treturn this._setter ? this._data[this._setter](value) : ((this._data[this._path] = value));\n};\n\n\nvar isArray = function(val) {\n\treturn val && val.splice && val.sort;\n};\n\nvar isSimilarArray = function(a,b) {\n\tlet l = a.length,i = 0;\n\tif (l != b.length) { return false };\n\twhile (i++ < l){\n\t\tif (a[i] != b[i]) { return false };\n\t};\n\treturn true;\n};\n\nImba.extendTag('input', function(tag){\n\ttag.prototype.lazy = function(v){ return this._lazy; }\n\ttag.prototype.setLazy = function(v){ this._lazy = v; return this; };\n\t\n\ttag.prototype.bindData = function (target,path,args){\n\t\tDataProxy.bind(this,target,path,args);\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.checked = function (){\n\t\treturn this._dom.checked;\n\t};\n\t\n\ttag.prototype.setChecked = function (value){\n\t\tif (!!value != this._dom.checked) {\n\t\t\tthis._dom.checked = !!value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setValue = function (value){\n\t\tif (this._localValue == undefined) {\n\t\t\tthis.dom().value = this._value = value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.oninput = function (e){\n\t\tlet val = this._dom.value;\n\t\tthis._localValue = val;\n\t\tif (this._data && !(this.lazy())) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.onchange = function (e){\n\t\tthis._modelValue = this._localValue = undefined;\n\t\tif (!(this.data())) { return };\n\t\t\n\t\tif (this.type() == 'radio' || this.type() == 'checkbox') {\n\t\t\tlet checked = this._dom.checked;\n\t\t\tlet mval = this._data.getFormValue(this);\n\t\t\tlet dval = (this._value != undefined) ? this._value : this.value();\n\t\t\t\n\t\t\tif (this.type() == 'radio') {\n\t\t\t\treturn this._data.setFormValue(dval,this);\n\t\t\t} else if (this.dom().value == 'on') {\n\t\t\t\treturn this._data.setFormValue(!!checked,this);\n\t\t\t} else if (isArray(mval)) {\n\t\t\t\tlet idx = mval.indexOf(dval);\n\t\t\t\tif (checked && idx == -1) {\n\t\t\t\t\treturn mval.push(dval);\n\t\t\t\t} else if (!checked && idx >= 0) {\n\t\t\t\t\treturn mval.splice(idx,1);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn this._data.setFormValue(dval,this);\n\t\t\t};\n\t\t} else {\n\t\t\treturn this._data.setFormValue(this.value());\n\t\t};\n\t};\n\t\n\ttag.prototype.onblur = function (e){\n\t\treturn this._localValue = undefined;\n\t};\n\t\n\t// overriding end directly for performance\n\ttag.prototype.end = function (){\n\t\tif (this._localValue !== undefined || !this._data) {\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tlet mval = this._data.getFormValue(this);\n\t\tif (mval == this._modelValue) { return this };\n\t\tif (!isArray(mval)) { this._modelValue = mval };\n\t\t\n\t\tif (this.type() == 'radio' || this.type() == 'checkbox') {\n\t\t\tlet dval = this._value;\n\t\t\tlet checked = isArray(mval) ? (\n\t\t\t\tmval.indexOf(dval) >= 0\n\t\t\t) : ((this.dom().value == 'on') ? (\n\t\t\t\t!!mval\n\t\t\t) : (\n\t\t\t\tmval == this._value\n\t\t\t));\n\t\t\t\n\t\t\tthis._dom.checked = checked;\n\t\t} else {\n\t\t\tthis._dom.value = mval;\n\t\t};\n\t\treturn this;\n\t};\n});\n\nImba.extendTag('textarea', function(tag){\n\ttag.prototype.lazy = function(v){ return this._lazy; }\n\ttag.prototype.setLazy = function(v){ this._lazy = v; return this; };\n\t\n\ttag.prototype.bindData = function (target,path,args){\n\t\tDataProxy.bind(this,target,path,args);\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setValue = function (value){\n\t\tif (this._localValue == undefined) { this.dom().value = value };\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.oninput = function (e){\n\t\tlet val = this._dom.value;\n\t\tthis._localValue = val;\n\t\tif (this._data && !(this.lazy())) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.onchange = function (e){\n\t\tthis._localValue = undefined;\n\t\tif (this._data) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.onblur = function (e){\n\t\treturn this._localValue = undefined;\n\t};\n\t\n\ttag.prototype.render = function (){\n\t\tif (this._localValue != undefined || !this._data) { return };\n\t\tif (this._data) {\n\t\t\tlet dval = this._data.getFormValue(this);\n\t\t\tthis._dom.value = (dval != undefined) ? dval : '';\n\t\t};\n\t\treturn this;\n\t};\n});\n\nImba.extendTag('option', function(tag){\n\ttag.prototype.setValue = function (value){\n\t\tif (value != this._value) {\n\t\t\tthis.dom().value = this._value = value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.value = function (){\n\t\treturn this._value || this.dom().value;\n\t};\n});\n\nImba.extendTag('select', function(tag){\n\ttag.prototype.bindData = function (target,path,args){\n\t\tDataProxy.bind(this,target,path,args);\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.setValue = function (value,syncing){\n\t\tlet prev = this._value;\n\t\tthis._value = value;\n\t\tif (!syncing) { this.syncValue(value) };\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.syncValue = function (value){\n\t\tlet prev = this._syncValue;\n\t\t// check if value has changed\n\t\tif (this.multiple() && (value instanceof Array)) {\n\t\t\tif ((prev instanceof Array) && isSimilarArray(prev,value)) {\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\t// create a copy for syncValue\n\t\t\tvalue = value.slice();\n\t\t};\n\t\t\n\t\tthis._syncValue = value;\n\t\t// support array for multiple?\n\t\tif (typeof value == 'object') {\n\t\t\tlet mult = this.multiple() && (value instanceof Array);\n\t\t\t\n\t\t\tfor (let i = 0, items = iter$(this.dom().options), len = items.length, opt; i < len; i++) {\n\t\t\t\topt = items[i];\n\t\t\t\tlet oval = (opt._tag ? opt._tag.value() : opt.value);\n\t\t\t\tif (mult) {\n\t\t\t\t\topt.selected = value.indexOf(oval) >= 0;\n\t\t\t\t} else if (value == oval) {\n\t\t\t\t\tthis.dom().selectedIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t};\n\t\t} else {\n\t\t\tthis.dom().value = value;\n\t\t};\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.value = function (){\n\t\tif (this.multiple()) {\n\t\t\tlet res = [];\n\t\t\tfor (let i = 0, items = iter$(this.dom().selectedOptions), len = items.length, option; i < len; i++) {\n\t\t\t\toption = items[i];\n\t\t\t\tres.push(option._tag ? option._tag.value() : option.value);\n\t\t\t};\n\t\t\treturn res;\n\t\t} else {\n\t\t\tlet opt = this.dom().selectedOptions[0];\n\t\t\treturn opt ? ((opt._tag ? opt._tag.value() : opt.value)) : null;\n\t\t};\n\t};\n\t\n\ttag.prototype.onchange = function (e){\n\t\tif (this._data) { return this._data.setFormValue(this.value(),this) };\n\t};\n\t\n\ttag.prototype.end = function (){\n\t\tif (this._data) {\n\t\t\tthis.setValue(this._data.getFormValue(this),1);\n\t\t};\n\t\t\n\t\tif (this._value != this._syncValue) {\n\t\t\tthis.syncValue(this._value);\n\t\t};\n\t\treturn this;\n\t};\n});\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/html.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/index.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/index.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\n__webpack_require__(/*! ./manager */ \"./node_modules/imba/src/imba/dom/manager.imba\");\n__webpack_require__(/*! ./event-manager */ \"./node_modules/imba/src/imba/dom/event-manager.imba\");\n\nImba.TagManager = new Imba.TagManagerClass();\n\n__webpack_require__(/*! ./tag */ \"./node_modules/imba/src/imba/dom/tag.imba\");\n__webpack_require__(/*! ./html */ \"./node_modules/imba/src/imba/dom/html.imba\");\n__webpack_require__(/*! ./pointer */ \"./node_modules/imba/src/imba/dom/pointer.imba\");\n__webpack_require__(/*! ./touch */ \"./node_modules/imba/src/imba/dom/touch.imba\");\n__webpack_require__(/*! ./event */ \"./node_modules/imba/src/imba/dom/event.imba\");\n\nif (true) {\n\t__webpack_require__(/*! ./reconciler */ \"./node_modules/imba/src/imba/dom/reconciler.imba\");\n};\n\nif (false) {};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/index.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/manager.imba":
/*!*****************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/manager.imba ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.TagManagerClass = function TagManagerClass(){\n\tthis._inserts = 0;\n\tthis._removes = 0;\n\tthis._mounted = [];\n\tthis._mountables = 0;\n\tthis._unmountables = 0;\n\tthis;\n};\n\nImba.TagManagerClass.prototype.mounted = function (){\n\treturn this._mounted;\n};\n\nImba.TagManagerClass.prototype.insert = function (node,parent){\n\tthis._inserts++;\n\tif (node && node.mount) {\n\t\tif (!(node.FLAGS & Imba.TAG_MOUNTABLE)) {\n\t\t\tnode.FLAGS |= Imba.TAG_MOUNTABLE;\n\t\t\tthis._mountables++;\n\t\t};\n\t};\n\treturn;\n};\n\nImba.TagManagerClass.prototype.remove = function (node,parent){\n\treturn this._removes++;\n};\n\n\nImba.TagManagerClass.prototype.changes = function (){\n\treturn this._inserts + this._removes;\n};\n\nImba.TagManagerClass.prototype.mount = function (node){\n\treturn;\n};\n\nImba.TagManagerClass.prototype.refresh = function (force){\n\tif(force === undefined) force = false;\n\tif (false) {};\n\tif (!force && this.changes() == 0) { return };\n\t// console.time('resolveMounts')\n\tif ((this._inserts && this._mountables > this._mounted.length) || force) {\n\t\tthis.tryMount();\n\t};\n\t\n\tif ((this._removes || force) && this._mounted.length) {\n\t\tthis.tryUnmount();\n\t};\n\t// console.timeEnd('resolveMounts')\n\tthis._inserts = 0;\n\tthis._removes = 0;\n\treturn this;\n};\n\nImba.TagManagerClass.prototype.unmount = function (node){\n\treturn this;\n};\n\nImba.TagManagerClass.prototype.tryMount = function (){\n\tvar count = 0;\n\tvar root = document.body;\n\tvar items = root.querySelectorAll('.__mount');\n\t// what if we end up creating additional mountables by mounting?\n\tfor (let i = 0, ary = iter$(items), len = ary.length, el; i < len; i++) {\n\t\tel = ary[i];\n\t\tif (el && el._tag) {\n\t\t\tif (this._mounted.indexOf(el._tag) == -1) {\n\t\t\t\tthis.mountNode(el._tag);\n\t\t\t};\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.TagManagerClass.prototype.mountNode = function (node){\n\tif (this._mounted.indexOf(node) == -1) {\n\t\tthis._mounted.push(node);\n\t\tnode.FLAGS |= Imba.TAG_MOUNTED;\n\t\tif (node.mount) { node.mount() };\n\t\t// Mark all parents as mountable for faster unmount\n\t\tlet el = node.dom().parentNode;\n\t\twhile (el && el._tag && !el._tag.mount && !(el._tag.FLAGS & Imba.TAG_MOUNTABLE)){\n\t\t\tel._tag.FLAGS |= Imba.TAG_MOUNTABLE;\n\t\t\tel = el.parentNode;\n\t\t};\n\t};\n\t\n\treturn;\n};\n\nImba.TagManagerClass.prototype.tryUnmount = function (){\n\tvar count = 0;\n\tvar root = document.body;\n\tfor (let i = 0, items = iter$(this._mounted), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tif (!document.documentElement.contains(item._dom)) {\n\t\t\titem.FLAGS = item.FLAGS & ~Imba.TAG_MOUNTED;\n\t\t\tif (item.unmount && item._dom) {\n\t\t\t\titem.unmount();\n\t\t\t} else if (item._scheduler) {\n\t\t\t\t// MAYBE FIX THIS?\n\t\t\t\titem.unschedule();\n\t\t\t};\n\t\t\tthis._mounted[i] = null;\n\t\t\tcount++;\n\t\t};\n\t};\n\t\n\tif (count) {\n\t\tthis._mounted = this._mounted.filter(function(item) { return item; });\n\t};\n\treturn this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/manager.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/pointer.imba":
/*!*****************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/pointer.imba ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.Pointer = function Pointer(){\n\tthis._button = -1;\n\tthis._event = {x: 0,y: 0,type: 'uninitialized'};\n\treturn this;\n};\n\nImba.Pointer.prototype.button = function (){\n\treturn this._button;\n};\n\nImba.Pointer.prototype.touch = function (){\n\treturn this._touch;\n};\n\nImba.Pointer.prototype.update = function (e){\n\tthis._event = e;\n\tthis._dirty = true;\n\treturn this;\n};\n\n// this is just for regular mouse now\nImba.Pointer.prototype.process = function (){\n\tvar e1 = this._event;\n\t\n\tif (this._dirty) {\n\t\tthis._prevEvent = e1;\n\t\tthis._dirty = false;\n\t\t\n\t\t// button should only change on mousedown etc\n\t\tif (e1.type == 'mousedown') {\n\t\t\tthis._button = e1.button;\n\t\t\t\n\t\t\tif ((this._touch && this._button != 0)) {\n\t\t\t\treturn;\n\t\t\t};\n\t\t\t\n\t\t\t// cancel the previous touch\n\t\t\tif (this._touch) { this._touch.cancel() };\n\t\t\tthis._touch = new Imba.Touch(e1,this);\n\t\t\tthis._touch.mousedown(e1,e1);\n\t\t} else if (e1.type == 'mousemove') {\n\t\t\tif (this._touch) { this._touch.mousemove(e1,e1) };\n\t\t} else if (e1.type == 'mouseup') {\n\t\t\tthis._button = -1;\n\t\t\t\n\t\t\tif (this._touch && this._touch.button() == e1.button) {\n\t\t\t\tthis._touch.mouseup(e1,e1);\n\t\t\t\tthis._touch = null;\n\t\t\t};\n\t\t\t// trigger pointerup\n\t\t};\n\t} else if (this._touch) {\n\t\tthis._touch.idle();\n\t};\n\treturn this;\n};\n\nImba.Pointer.prototype.x = function (){\n\treturn this._event.x;\n};\nImba.Pointer.prototype.y = function (){\n\treturn this._event.y;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/pointer.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/reconciler.imba":
/*!********************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/reconciler.imba ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\n// externs;\n\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nfunction removeNested(root,node,caret){\n\t// if node/nodes isa String\n\t// \twe need to use the caret to remove elements\n\t// \tfor now we will simply not support this\n\tif (node instanceof Array) {\n\t\tfor (let i = 0, items = iter$(node), len = items.length; i < len; i++) {\n\t\t\tremoveNested(root,items[i],caret);\n\t\t};\n\t} else if (node && node._slot_) {\n\t\troot.removeChild(node);\n\t} else if (node != null) {\n\t\t// what if this is not null?!?!?\n\t\t// take a chance and remove a text-elementng\n\t\tlet next = caret ? caret.nextSibling : root._dom.firstChild;\n\t\tif ((next instanceof Text) && next.textContent == node) {\n\t\t\troot.removeChild(next);\n\t\t} else {\n\t\t\tthrow 'cannot remove string';\n\t\t};\n\t};\n\t\n\treturn caret;\n};\n\nfunction appendNested(root,node){\n\tif (node instanceof Array) {\n\t\tlet i = 0;\n\t\tlet c = node.taglen;\n\t\tlet k = (c != null) ? ((node.domlen = c)) : node.length;\n\t\twhile (i < k){\n\t\t\tappendNested(root,node[i++]);\n\t\t};\n\t} else if (node && node._dom) {\n\t\troot.appendChild(node);\n\t} else if (node != null && node !== false) {\n\t\troot.appendChild(Imba.createTextNode(node));\n\t};\n\t\n\treturn;\n};\n\n\n// insert nodes before a certain node\n// does not need to return any tail, as before\n// will still be correct there\n// before must be an actual domnode\nfunction insertNestedBefore(root,node,before){\n\tif (node instanceof Array) {\n\t\tlet i = 0;\n\t\tlet c = node.taglen;\n\t\tlet k = (c != null) ? ((node.domlen = c)) : node.length;\n\t\twhile (i < k){\n\t\t\tinsertNestedBefore(root,node[i++],before);\n\t\t};\n\t} else if (node && node._dom) {\n\t\troot.insertBefore(node,before);\n\t} else if (node != null && node !== false) {\n\t\troot.insertBefore(Imba.createTextNode(node),before);\n\t};\n\t\n\treturn before;\n};\n\n// after must be an actual domnode\nfunction insertNestedAfter(root,node,after){\n\tvar before = after ? after.nextSibling : root._dom.firstChild;\n\t\n\tif (before) {\n\t\tinsertNestedBefore(root,node,before);\n\t\treturn before.previousSibling;\n\t} else {\n\t\tappendNested(root,node);\n\t\treturn root._dom.lastChild;\n\t};\n};\n\nfunction reconcileCollectionChanges(root,new$,old,caret){\n\t\n\tvar newLen = new$.length;\n\tvar lastNew = new$[newLen - 1];\n\t\n\t// This re-order algorithm is based on the following principle:\n\t// \n\t// We build a \"chain\" which shows which items are already sorted.\n\t// If we're going from [1, 2, 3] -> [2, 1, 3], the tree looks like:\n\t//\n\t// \t3 ->  0 (idx)\n\t// \t2 -> -1 (idx)\n\t// \t1 -> -1 (idx)\n\t//\n\t// This tells us that we have two chains of ordered items:\n\t// \n\t// \t(1, 3) and (2)\n\t// \n\t// The optimal re-ordering then becomes to keep the longest chain intact,\n\t// and move all the other items.\n\t\n\tvar newPosition = [];\n\t\n\t// The tree/graph itself\n\tvar prevChain = [];\n\t// The length of the chain\n\tvar lengthChain = [];\n\t\n\t// Keep track of the longest chain\n\tvar maxChainLength = 0;\n\tvar maxChainEnd = 0;\n\t\n\tvar hasTextNodes = false;\n\tvar newPos;\n\t\n\tfor (let idx = 0, items = iter$(old), len = items.length, node; idx < len; idx++) {\n\t\t// special case for Text nodes\n\t\tnode = items[idx];\n\t\tif (node && node.nodeType == 3) {\n\t\t\tnewPos = new$.indexOf(node.textContent);\n\t\t\tif (newPos >= 0) { new$[newPos] = node };\n\t\t\thasTextNodes = true;\n\t\t} else {\n\t\t\tnewPos = new$.indexOf(node);\n\t\t};\n\t\t\n\t\tnewPosition.push(newPos);\n\t\t\n\t\tif (newPos == -1) {\n\t\t\troot.removeChild(node);\n\t\t\tprevChain.push(-1);\n\t\t\tlengthChain.push(-1);\n\t\t\tcontinue;\n\t\t};\n\t\t\n\t\tvar prevIdx = newPosition.length - 2;\n\t\t\n\t\t// Build the chain:\n\t\twhile (prevIdx >= 0){\n\t\t\tif (newPosition[prevIdx] == -1) {\n\t\t\t\tprevIdx--;\n\t\t\t} else if (newPos > newPosition[prevIdx]) {\n\t\t\t\t// Yay, we're bigger than the previous!\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// Nope, let's walk back the chain\n\t\t\t\tprevIdx = prevChain[prevIdx];\n\t\t\t};\n\t\t};\n\t\t\n\t\tprevChain.push(prevIdx);\n\t\t\n\t\tvar currLength = (prevIdx == -1) ? 0 : (lengthChain[prevIdx] + 1);\n\t\t\n\t\tif (currLength > maxChainLength) {\n\t\t\tmaxChainLength = currLength;\n\t\t\tmaxChainEnd = idx;\n\t\t};\n\t\t\n\t\tlengthChain.push(currLength);\n\t};\n\t\n\tvar stickyNodes = [];\n\t\n\t// Now we can walk the longest chain backwards and mark them as \"sticky\",\n\t// which implies that they should not be moved\n\tvar cursor = newPosition.length - 1;\n\twhile (cursor >= 0){\n\t\tif (cursor == maxChainEnd && newPosition[cursor] != -1) {\n\t\t\tstickyNodes[newPosition[cursor]] = true;\n\t\t\tmaxChainEnd = prevChain[maxChainEnd];\n\t\t};\n\t\t\n\t\tcursor -= 1;\n\t};\n\t\n\t// possible to do this in reversed order instead?\n\tfor (let idx = 0, items = iter$(new$), len = items.length, node; idx < len; idx++) {\n\t\tnode = items[idx];\n\t\tif (!stickyNodes[idx]) {\n\t\t\t// create textnode for string, and update the array\n\t\t\tif (!(node && node._dom)) {\n\t\t\t\tnode = new$[idx] = Imba.createTextNode(node);\n\t\t\t};\n\t\t\t\n\t\t\tvar after = new$[idx - 1];\n\t\t\tinsertNestedAfter(root,node,(after && after._slot_ || after || caret));\n\t\t};\n\t\t\n\t\tcaret = node._slot_ || (caret && caret.nextSibling || root._dom.firstChild);\n\t};\n\t\n\t// should trust that the last item in new list is the caret\n\treturn lastNew && lastNew._slot_ || caret;\n};\n\n\n// expects a flat non-sparse array of nodes in both new and old, always\nfunction reconcileCollection(root,new$,old,caret){\n\tvar k = new$.length;\n\tvar i = k;\n\tvar last = new$[k - 1];\n\t\n\t\n\tif (k == old.length && new$[0] === old[0]) {\n\t\t// running through to compare\n\t\twhile (i--){\n\t\t\tif (new$[i] !== old[i]) { break; };\n\t\t};\n\t};\n\t\n\tif (i == -1) {\n\t\treturn last && last._slot_ || last || caret;\n\t} else {\n\t\treturn reconcileCollectionChanges(root,new$,old,caret);\n\t};\n};\n\n// TYPE 5 - we know that we are dealing with a single array of\n// keyed tags - and root has no other children\nfunction reconcileLoop(root,new$,old,caret){\n\tvar nl = new$.length;\n\tvar ol = old.length;\n\tvar cl = new$.cache.i$; // cache-length\n\tvar i = 0,d = nl - ol;\n\t\n\t// TODO support caret\n\t\n\t// find the first index that is different\n\twhile (i < ol && i < nl && new$[i] === old[i]){\n\t\ti++;\n\t};\n\t\n\t// conditionally prune cache\n\tif (cl > 1000 && (cl - nl) > 500) {\n\t\tnew$.cache.$prune(new$);\n\t};\n\t\n\tif (d > 0 && i == ol) {\n\t\t// added at end\n\t\twhile (i < nl){\n\t\t\troot.appendChild(new$[i++]);\n\t\t};\n\t\treturn;\n\t} else if (d > 0) {\n\t\tlet i1 = nl;\n\t\twhile (i1 > i && new$[i1 - 1] === old[i1 - 1 - d]){\n\t\t\ti1--;\n\t\t};\n\t\t\n\t\tif (d == (i1 - i)) {\n\t\t\tlet before = old[i]._slot_;\n\t\t\twhile (i < i1){\n\t\t\t\troot.insertBefore(new$[i++],before);\n\t\t\t};\n\t\t\treturn;\n\t\t};\n\t} else if (d < 0 && i == nl) {\n\t\t// removed at end\n\t\twhile (i < ol){\n\t\t\troot.removeChild(old[i++]);\n\t\t};\n\t\treturn;\n\t} else if (d < 0) {\n\t\tlet i1 = ol;\n\t\twhile (i1 > i && new$[i1 - 1 + d] === old[i1 - 1]){\n\t\t\ti1--;\n\t\t};\n\t\t\n\t\tif (d == (i - i1)) {\n\t\t\twhile (i < i1){\n\t\t\t\troot.removeChild(old[i++]);\n\t\t\t};\n\t\t\treturn;\n\t\t};\n\t} else if (i == nl) {\n\t\treturn;\n\t};\n\t\n\treturn reconcileCollectionChanges(root,new$,old,caret);\n};\n\n// expects a flat non-sparse array of nodes in both new and old, always\nfunction reconcileIndexedArray(root,array,old,caret){\n\tvar newLen = array.taglen;\n\tvar prevLen = array.domlen || 0;\n\tvar last = newLen ? array[newLen - 1] : null;\n\t// console.log \"reconcile optimized array(!)\",caret,newLen,prevLen,array\n\t\n\tif (prevLen > newLen) {\n\t\twhile (prevLen > newLen){\n\t\t\tvar item = array[--prevLen];\n\t\t\troot.removeChild(item._slot_);\n\t\t};\n\t} else if (newLen > prevLen) {\n\t\t// find the item to insert before\n\t\tlet prevLast = prevLen ? array[prevLen - 1]._slot_ : caret;\n\t\tlet before = prevLast ? prevLast.nextSibling : root._dom.firstChild;\n\t\t\n\t\twhile (prevLen < newLen){\n\t\t\tlet node = array[prevLen++];\n\t\t\tbefore ? root.insertBefore(node._slot_,before) : root.appendChild(node._slot_);\n\t\t};\n\t};\n\t\n\tarray.domlen = newLen;\n\treturn last ? last._slot_ : caret;\n};\n\n\n// the general reconciler that respects conditions etc\n// caret is the current node we want to insert things after\nfunction reconcileNested(root,new$,old,caret){\n\t\n\t// var skipnew = new == null or new === false or new === true\n\tvar newIsNull = new$ == null || new$ === false;\n\tvar oldIsNull = old == null || old === false;\n\t\n\t\n\tif (new$ === old) {\n\t\t// remember that the caret must be an actual dom element\n\t\t// we should instead move the actual caret? - trust\n\t\tif (newIsNull) {\n\t\t\treturn caret;\n\t\t} else if (new$._slot_) {\n\t\t\treturn new$._slot_;\n\t\t} else if ((new$ instanceof Array) && new$.taglen != null) {\n\t\t\treturn reconcileIndexedArray(root,new$,old,caret);\n\t\t} else {\n\t\t\treturn caret ? caret.nextSibling : root._dom.firstChild;\n\t\t};\n\t} else if (new$ instanceof Array) {\n\t\tif (old instanceof Array) {\n\t\t\t// look for slot instead?\n\t\t\tlet typ = new$.static;\n\t\t\tif (typ || old.static) {\n\t\t\t\t// if the static is not nested - we could get a hint from compiler\n\t\t\t\t// and just skip it\n\t\t\t\tif (typ == old.static) { // should also include a reference?\n\t\t\t\t\tfor (let i = 0, items = iter$(new$), len = items.length; i < len; i++) {\n\t\t\t\t\t\t// this is where we could do the triple equal directly\n\t\t\t\t\t\tcaret = reconcileNested(root,items[i],old[i],caret);\n\t\t\t\t\t};\n\t\t\t\t\treturn caret;\n\t\t\t\t} else {\n\t\t\t\t\tremoveNested(root,old,caret);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\t// if they are not the same we continue through to the default\n\t\t\t} else {\n\t\t\t\t// Could use optimized loop if we know that it only consists of nodes\n\t\t\t\treturn reconcileCollection(root,new$,old,caret);\n\t\t\t};\n\t\t} else if (!oldIsNull) {\n\t\t\tif (old._slot_) {\n\t\t\t\troot.removeChild(old);\n\t\t\t} else {\n\t\t\t\t// old was a string-like object?\n\t\t\t\troot.removeChild(caret ? caret.nextSibling : root._dom.firstChild);\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn insertNestedAfter(root,new$,caret);\n\t\t// remove old\n\t} else if (!newIsNull && new$._slot_) {\n\t\tif (!oldIsNull) { removeNested(root,old,caret) };\n\t\treturn insertNestedAfter(root,new$,caret);\n\t} else if (newIsNull) {\n\t\tif (!oldIsNull) { removeNested(root,old,caret) };\n\t\treturn caret;\n\t} else {\n\t\t// if old did not exist we need to add a new directly\n\t\tlet nextNode;\n\t\t// if old was array or imbatag we need to remove it and then add\n\t\tif (old instanceof Array) {\n\t\t\tremoveNested(root,old,caret);\n\t\t} else if (old && old._slot_) {\n\t\t\troot.removeChild(old);\n\t\t} else if (!oldIsNull) {\n\t\t\t// ...\n\t\t\tnextNode = caret ? caret.nextSibling : root._dom.firstChild;\n\t\t\tif ((nextNode instanceof Text) && nextNode.textContent != new$) {\n\t\t\t\tnextNode.textContent = new$;\n\t\t\t\treturn nextNode;\n\t\t\t};\n\t\t};\n\t\t\n\t\t// now add the textnode\n\t\treturn insertNestedAfter(root,new$,caret);\n\t};\n};\n\n\nImba.extendTag('element', function(tag){\n\t\n\t// 1 - static shape - unknown content\n\t// 2 - static shape and static children\n\t// 3 - single item\n\t// 4 - optimized array - only length will change\n\t// 5 - optimized collection\n\t// 6 - text only\n\t\n\ttag.prototype.setChildren = function (new$,typ){\n\t\t// if typeof new == 'string'\n\t\t// \treturn self.text = new\n\t\tvar old = this._tree_;\n\t\t\n\t\tif (new$ === old && (!(new$) || new$.taglen == undefined)) {\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tif (!old && typ != 3) {\n\t\t\tthis.removeAllChildren();\n\t\t\tappendNested(this,new$);\n\t\t} else if (typ == 1) {\n\t\t\tlet caret = null;\n\t\t\tfor (let i = 0, items = iter$(new$), len = items.length; i < len; i++) {\n\t\t\t\tcaret = reconcileNested(this,items[i],old[i],caret);\n\t\t\t};\n\t\t} else if (typ == 2) {\n\t\t\treturn this;\n\t\t} else if (typ == 3) {\n\t\t\tlet ntyp = typeof new$;\n\t\t\t\n\t\t\tif (ntyp != 'object') {\n\t\t\t\treturn this.setText(new$);\n\t\t\t};\n\t\t\t\n\t\t\tif (new$ && new$._dom) {\n\t\t\t\tthis.removeAllChildren();\n\t\t\t\tthis.appendChild(new$);\n\t\t\t} else if (new$ instanceof Array) {\n\t\t\t\tif (new$._type == 5 && old && old._type == 5) {\n\t\t\t\t\treconcileLoop(this,new$,old,null);\n\t\t\t\t} else if (old instanceof Array) {\n\t\t\t\t\treconcileNested(this,new$,old,null);\n\t\t\t\t} else {\n\t\t\t\t\tthis.removeAllChildren();\n\t\t\t\t\tappendNested(this,new$);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn this.setText(new$);\n\t\t\t};\n\t\t} else if (typ == 4) {\n\t\t\treconcileIndexedArray(this,new$,old,null);\n\t\t} else if (typ == 5) {\n\t\t\treconcileLoop(this,new$,old,null);\n\t\t} else if ((new$ instanceof Array) && (old instanceof Array)) {\n\t\t\treconcileNested(this,new$,old,null);\n\t\t} else {\n\t\t\t// what if text?\n\t\t\tthis.removeAllChildren();\n\t\t\tappendNested(this,new$);\n\t\t};\n\t\t\n\t\tthis._tree_ = new$;\n\t\treturn this;\n\t};\n\t\n\ttag.prototype.content = function (){\n\t\treturn this._content || this.children().toArray();\n\t};\n\t\n\ttag.prototype.setText = function (text){\n\t\tif (text != this._tree_) {\n\t\t\tvar val = (text === null || text === false) ? '' : text;\n\t\t\t(this._text_ || this._dom).textContent = val;\n\t\t\tthis._text_ || (this._text_ = this._dom.firstChild);\n\t\t\tthis._tree_ = text;\n\t\t};\n\t\treturn this;\n\t};\n});\n\n// alias setContent to setChildren\nvar proto = Imba.Tag.prototype;\nproto.setContent = proto.setChildren;\n\n// optimization for setText\nvar apple = typeof navigator != 'undefined' && (navigator.vendor || '').indexOf('Apple') == 0;\nif (apple) {\n\tproto.setText = function (text){\n\t\tif (text != this._tree_) {\n\t\t\tthis._dom.textContent = ((text === null || text === false) ? '' : text);\n\t\t\tthis._tree_ = text;\n\t\t};\n\t\treturn this;\n\t};\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/reconciler.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/tag.imba":
/*!*************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/tag.imba ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nImba.CSSKeyMap = {};\n\nImba.TAG_BUILT = 1;\nImba.TAG_SETUP = 2;\nImba.TAG_MOUNTING = 4;\nImba.TAG_MOUNTED = 8;\nImba.TAG_SCHEDULED = 16;\nImba.TAG_AWAKENED = 32;\nImba.TAG_MOUNTABLE = 64;\n\n/*\nGet the current document\n*/\n\nImba.document = function (){\n\tif (true) {\n\t\treturn window.document;\n\t};\n};\n\n/*\nGet the body element wrapped in an Imba.Tag\n*/\n\nImba.root = function (){\n\treturn Imba.getTagForDom(Imba.document().body);\n};\n\nImba.static = function (items,typ,nr){\n\titems._type = typ;\n\titems.static = nr;\n\treturn items;\n};\n\n/*\n\n*/\n\nImba.mount = function (node,into){\n\tinto || (into = Imba.document().body);\n\tinto.appendChild(node.dom());\n\tImba.TagManager.insert(node,into);\n\tnode.scheduler().configure({events: true}).activate(false);\n\tImba.TagManager.refresh();\n\treturn node;\n};\n\n\nImba.createTextNode = function (node){\n\tif (node && node.nodeType == 3) {\n\t\treturn node;\n\t};\n\treturn Imba.document().createTextNode(node);\n};\n\n\n\n/*\nThis is the baseclass that all tags in imba inherit from.\n@iname node\n*/\n\nImba.Tag = function Tag(dom,ctx){\n\tthis.setDom(dom);\n\tthis.$ = TagCache.build(this);\n\tthis.$up = this._owner_ = ctx;\n\tthis._tree_ = null;\n\tthis.FLAGS = 0;\n\tthis.build();\n\tthis;\n};\n\nImba.Tag.buildNode = function (){\n\tvar dom = Imba.document().createElement(this._nodeType || 'div');\n\tif (this._classes) {\n\t\tvar cls = this._classes.join(\" \");\n\t\tif (cls) { dom.className = cls };\n\t};\n\treturn dom;\n};\n\nImba.Tag.createNode = function (){\n\tvar proto = (this._protoDom || (this._protoDom = this.buildNode()));\n\treturn proto.cloneNode(false);\n};\n\nImba.Tag.build = function (ctx){\n\treturn new this(this.createNode(),ctx);\n};\n\nImba.Tag.dom = function (){\n\treturn this._protoDom || (this._protoDom = this.buildNode());\n};\n\nImba.Tag.end = function (){\n\treturn this.commit(0);\n};\n\n/*\n\tCalled when a tag type is being subclassed.\n\t*/\n\nImba.Tag.inherit = function (child){\n\tchild._protoDom = null;\n\t\n\tif (this._nodeType) {\n\t\tchild._nodeType = this._nodeType;\n\t\tchild._classes = this._classes.slice();\n\t\t\n\t\tif (child._flagName) {\n\t\t\treturn child._classes.push(child._flagName);\n\t\t};\n\t} else {\n\t\tchild._nodeType = child._name;\n\t\tchild._flagName = null;\n\t\treturn child._classes = [];\n\t};\n};\n\n/*\n\tInternal method called after a tag class has\n\tbeen declared or extended.\n\t\n\t@private\n\t*/\n\nImba.Tag.prototype.optimizeTagStructure = function (){\n\tif (false) {};\n\tvar ctor = this.constructor;\n\tlet keys = Object.keys(this);\n\t\n\tif (keys.indexOf('mount') >= 0) {\n\t\tif (ctor._classes && ctor._classes.indexOf('__mount') == -1) {\n\t\t\tctor._classes.push('__mount');\n\t\t};\n\t\t\n\t\tif (ctor._protoDom) {\n\t\t\tctor._protoDom.classList.add('__mount');\n\t\t};\n\t};\n\t\n\tfor (let i = 0, items = iter$(keys), len = items.length, key; i < len; i++) {\n\t\tkey = items[i];\n\t\tif ((/^on/).test(key)) { Imba.EventManager.bind(key.slice(2)) };\n\t};\n\treturn this;\n};\n\n\nImba.attr(Imba.Tag,'name');\nImba.attr(Imba.Tag,'role');\nImba.attr(Imba.Tag,'tabindex');\nImba.Tag.prototype.title = function(v){ return this.getAttribute('title'); }\nImba.Tag.prototype.setTitle = function(v){ this.setAttribute('title',v); return this; };\n\nImba.Tag.prototype.dom = function (){\n\treturn this._dom;\n};\n\nImba.Tag.prototype.setDom = function (dom){\n\tdom._tag = this;\n\tthis._dom = this._slot_ = dom;\n\treturn this;\n};\n\nImba.Tag.prototype.ref = function (){\n\treturn this._ref;\n};\n\nImba.Tag.prototype.root = function (){\n\treturn this._owner_ ? this._owner_.root() : this;\n};\n\n/*\n\tSetting references for tags like\n\t`<div@header>` will compile to `tag('div').ref_('header',this).end()`\n\tBy default it adds the reference as a className to the tag.\n\n\t@return {self}\n\t@private\n\t*/\n\nImba.Tag.prototype.ref_ = function (ref){\n\tthis.flag(this._ref = ref);\n\treturn this;\n};\n\n/*\n\tSet the data object for node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setData = function (data){\n\tthis._data = data;\n\treturn this;\n};\n\n/*\n\tGet the data object for node\n\t*/\n\nImba.Tag.prototype.data = function (){\n\treturn this._data;\n};\n\n\nImba.Tag.prototype.bindData = function (target,path,args){\n\treturn this.setData(args ? target[path].apply(target,args) : target[path]);\n};\n\n/*\n\tSet inner html of node\n\t*/\n\nImba.Tag.prototype.setHtml = function (html){\n\tif (this.html() != html) {\n\t\tthis._dom.innerHTML = html;\n\t};\n\treturn this;\n};\n\n/*\n\tGet inner html of node\n\t*/\n\nImba.Tag.prototype.html = function (){\n\treturn this._dom.innerHTML;\n};\n\nImba.Tag.prototype.on$ = function (slot,handler,context){\n\tlet handlers = this._on_ || (this._on_ = []);\n\tlet prev = handlers[slot];\n\t// self-bound handlers\n\tif (slot < 0) {\n\t\tif (prev == undefined) {\n\t\t\tslot = handlers[slot] = handlers.length;\n\t\t} else {\n\t\t\tslot = prev;\n\t\t};\n\t\tprev = handlers[slot];\n\t};\n\t\n\thandlers[slot] = handler;\n\tif (prev) {\n\t\thandler.state = prev.state;\n\t} else {\n\t\thandler.state = {context: context};\n\t\tif (true) { Imba.EventManager.bind(handler[0]) };\n\t};\n\treturn this;\n};\n\n\nImba.Tag.prototype.setId = function (id){\n\tif (id != null) {\n\t\tthis.dom().id = id;\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.id = function (){\n\treturn this.dom().id;\n};\n\n/*\n\tAdds a new attribute or changes the value of an existing attribute\n\ton the specified tag. If the value is null or false, the attribute\n\twill be removed.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setAttribute = function (name,value){\n\tvar old = this.dom().getAttribute(name);\n\t\n\tif (old == value) {\n\t\tvalue;\n\t} else if (value != null && value !== false) {\n\t\tthis.dom().setAttribute(name,value);\n\t} else {\n\t\tthis.dom().removeAttribute(name);\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.setNestedAttr = function (ns,name,value){\n\tif (this[ns + 'SetAttribute']) {\n\t\tthis[ns + 'SetAttribute'](name,value);\n\t} else {\n\t\tthis.setAttributeNS(ns,name,value);\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.setAttributeNS = function (ns,name,value){\n\tvar old = this.getAttributeNS(ns,name);\n\t\n\tif (old != value) {\n\t\tif (value != null && value !== false) {\n\t\t\tthis.dom().setAttributeNS(ns,name,value);\n\t\t} else {\n\t\t\tthis.dom().removeAttributeNS(ns,name);\n\t\t};\n\t};\n\treturn this;\n};\n\n\n/*\n\tremoves an attribute from the specified tag\n\t*/\n\nImba.Tag.prototype.removeAttribute = function (name){\n\treturn this.dom().removeAttribute(name);\n};\n\n/*\n\treturns the value of an attribute on the tag.\n\tIf the given attribute does not exist, the value returned\n\twill either be null or \"\" (the empty string)\n\t*/\n\nImba.Tag.prototype.getAttribute = function (name){\n\treturn this.dom().getAttribute(name);\n};\n\n\nImba.Tag.prototype.getAttributeNS = function (ns,name){\n\treturn this.dom().getAttributeNS(ns,name);\n};\n\n\nImba.Tag.prototype.set = function (key,value,mods){\n\tlet setter = Imba.toSetter(key);\n\tif (this[setter] instanceof Function) {\n\t\tthis[setter](value,mods);\n\t} else {\n\t\tthis._dom.setAttribute(key,value);\n\t};\n\treturn this;\n};\n\n\nImba.Tag.prototype.get = function (key){\n\treturn this._dom.getAttribute(key);\n};\n\n/*\n\tOverride this to provide special wrapping etc.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setContent = function (content,type){\n\tthis.setChildren(content,type);\n\treturn this;\n};\n\n/*\n\tSet the children of node. type param is optional,\n\tand should only be used by Imba when compiling tag trees. \n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setChildren = function (nodes,type){\n\t// overridden on client by reconciler\n\tthis._tree_ = nodes;\n\treturn this;\n};\n\n/*\n\tSet the template that will render the content of node.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setTemplate = function (template){\n\tif (!this._template) {\n\t\tif (this.render == Imba.Tag.prototype.render) {\n\t\t\tthis.render = this.renderTemplate; // do setChildren(renderTemplate)\n\t\t};\n\t};\n\t\n\tthis.template = this._template = template;\n\treturn this;\n};\n\nImba.Tag.prototype.template = function (){\n\treturn null;\n};\n\n/*\n\tIf no custom render-method is defined, and the node\n\thas a template, this method will be used to render\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.renderTemplate = function (){\n\tvar body = this.template();\n\tif (body != this) { this.setChildren(body) };\n\treturn this;\n};\n\n\n/*\n\tRemove specified child from current node.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.removeChild = function (child){\n\tvar par = this.dom();\n\tvar el = child._slot_ || child;\n\tif (el && el.parentNode == par) {\n\t\tImba.TagManager.remove(el._tag || el,this);\n\t\tpar.removeChild(el);\n\t};\n\treturn this;\n};\n\n/*\n\tRemove all content inside node\n\t*/\n\nImba.Tag.prototype.removeAllChildren = function (){\n\tif (this._dom.firstChild) {\n\t\tvar el;\n\t\twhile (el = this._dom.firstChild){\n\t\t\ttrue && Imba.TagManager.remove(el._tag || el,this);\n\t\t\tthis._dom.removeChild(el);\n\t\t};\n\t};\n\tthis._tree_ = this._text_ = null;\n\treturn this;\n};\n\n/*\n\tAppend a single item (node or string) to the current node.\n\tIf supplied item is a string it will automatically. This is used\n\tby Imba internally, but will practically never be used explicitly.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.appendChild = function (node){\n\tif ((typeof node=='string'||node instanceof String)) {\n\t\tthis.dom().appendChild(Imba.document().createTextNode(node));\n\t} else if (node) {\n\t\tthis.dom().appendChild(node._slot_ || node);\n\t\tImba.TagManager.insert(node._tag || node,this);\n\t\t// FIXME ensure these are not called for text nodes\n\t};\n\treturn this;\n};\n\n/*\n\tInsert a node into the current node (self), before another.\n\tThe relative node must be a child of current node. \n\t*/\n\nImba.Tag.prototype.insertBefore = function (node,rel){\n\tif ((typeof node=='string'||node instanceof String)) {\n\t\tnode = Imba.document().createTextNode(node);\n\t};\n\t\n\tif (node && rel) {\n\t\tthis.dom().insertBefore((node._slot_ || node),(rel._slot_ || rel));\n\t\tImba.TagManager.insert(node._tag || node,this);\n\t\t// FIXME ensure these are not called for text nodes\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.detachFromParent = function (){\n\tif (this._slot_ == this._dom) {\n\t\tthis._slot_ = (this._dom._placeholder_ || (this._dom._placeholder_ = Imba.document().createComment(\"node\")));\n\t\tthis._slot_._tag || (this._slot_._tag = this);\n\t\t\n\t\tif (this._dom.parentNode) {\n\t\t\tImba.TagManager.remove(this,this._dom.parentNode);\n\t\t\tthis._dom.parentNode.replaceChild(this._slot_,this._dom);\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.attachToParent = function (){\n\tif (this._slot_ != this._dom) {\n\t\tlet prev = this._slot_;\n\t\tthis._slot_ = this._dom;\n\t\tif (prev && prev.parentNode) {\n\t\t\tImba.TagManager.insert(this);\n\t\t\tprev.parentNode.replaceChild(this._dom,prev);\n\t\t};\n\t};\n\t\n\treturn this;\n};\n\n/*\n\tRemove node from the dom tree\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.orphanize = function (){\n\tvar par;\n\tif (par = this.parent()) { par.removeChild(this) };\n\treturn this;\n};\n\n/*\n\tGet text of node. Uses textContent behind the scenes (not innerText)\n\t[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()\n\t@return {string} inner text of node\n\t*/\n\nImba.Tag.prototype.text = function (v){\n\treturn this._dom.textContent;\n};\n\n/*\n\tSet text of node. Uses textContent behind the scenes (not innerText)\n\t[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()\n\t*/\n\nImba.Tag.prototype.setText = function (txt){\n\tthis._tree_ = txt;\n\tthis._dom.textContent = (txt == null || this.text() === false) ? '' : txt;\n\tthis;\n\treturn this;\n};\n\n\n/*\n\tMethod for getting and setting data-attributes. When called with zero\n\targuments it will return the actual dataset for the tag.\n\n\t\tvar node = <div data-name='hello'>\n\t\t# get the whole dataset\n\t\tnode.dataset # {name: 'hello'}\n\t\t# get a single value\n\t\tnode.dataset('name') # 'hello'\n\t\t# set a single value\n\t\tnode.dataset('name','newname') # self\n\n\n\t*/\n\nImba.Tag.prototype.dataset = function (key,val){\n\tif (key instanceof Object) {\n\t\tfor (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){\n\t\t\tk = keys[i];v = key[k];this.dataset(k,v);\n\t\t};\n\t\treturn this;\n\t};\n\t\n\tif (arguments.length == 2) {\n\t\tthis.setAttribute((\"data-\" + key),val);\n\t\treturn this;\n\t};\n\t\n\tif (key) {\n\t\treturn this.getAttribute((\"data-\" + key));\n\t};\n\t\n\tvar dataset = this.dom().dataset;\n\t\n\tif (!dataset) {\n\t\tdataset = {};\n\t\tfor (let i = 0, items = iter$(this.dom().attributes), len = items.length, atr; i < len; i++) {\n\t\t\tatr = items[i];\n\t\t\tif (atr.name.substr(0,5) == 'data-') {\n\t\t\t\tdataset[Imba.toCamelCase(atr.name.slice(5))] = atr.value;\n\t\t\t};\n\t\t};\n\t};\n\t\n\treturn dataset;\n};\n\n/*\n\tEmpty placeholder. Override to implement custom render behaviour.\n\tWorks much like the familiar render-method in React.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.render = function (){\n\treturn this;\n};\n\n/*\n\tCalled implicitly while tag is initializing. No initial props\n\twill have been set at this point.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.build = function (){\n\treturn this;\n};\n\n/*\n\tCalled once, implicitly through Imba.Tag#end. All initial props\n\tand children will have been set before setup is called.\n\tsetContent.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setup = function (){\n\treturn this;\n};\n\n/*\n\tCalled implicitly through Imba.Tag#end, for tags that are part of\n\ta tag tree (that are rendered several times).\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.commit = function (){\n\tif (this.beforeRender() !== false) this.render();\n\treturn this;\n};\n\nImba.Tag.prototype.beforeRender = function (){\n\treturn this;\n};\n\n/*\n\n\tCalled by the tag-scheduler (if this tag is scheduled)\n\tBy default it will call this.render. Do not override unless\n\tyou really understand it.\n\n\t*/\n\nImba.Tag.prototype.tick = function (){\n\tif (this.beforeRender() !== false) this.render();\n\treturn this;\n};\n\n/*\n\t\n\tA very important method that you will practically never manually.\n\tThe tag syntax of Imba compiles to a chain of setters, which always\n\tends with .end. `<a.large>` compiles to `tag('a').flag('large').end()`\n\t\n\tYou are highly adviced to not override its behaviour. The first time\n\tend is called it will mark the tag as initialized and call Imba.Tag#setup,\n\tand call Imba.Tag#commit every time.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.end = function (){\n\tthis.setup();\n\tthis.commit(0);\n\tthis.end = Imba.Tag.end;\n\treturn this;\n};\n\n// called on <self> to check if self is called from other places\nImba.Tag.prototype.$open = function (context){\n\tif (context != this._context_) {\n\t\tthis._tree_ = null;\n\t\tthis._context_ = context;\n\t};\n\treturn this;\n};\n\n/*\n\tThis is called instead of Imba.Tag#end for `<self>` tag chains.\n\tDefaults to noop\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.synced = function (){\n\treturn this;\n};\n\n// called when the node is awakened in the dom - either automatically\n// upon attachment to the dom-tree, or the first time imba needs the\n// tag for a domnode that has been rendered on the server\nImba.Tag.prototype.awaken = function (){\n\treturn this;\n};\n\n/*\n\tList of flags for this node. \n\t*/\n\nImba.Tag.prototype.flags = function (){\n\treturn this._dom.classList;\n};\n\n/*\n\tAdd speficied flag to current node.\n\tIf a second argument is supplied, it will be coerced into a Boolean,\n\tand used to indicate whether we should remove the flag instead.\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.flag = function (name,toggler){\n\t// it is most natural to treat a second undefined argument as a no-switch\n\t// so we need to check the arguments-length\n\tif (arguments.length == 2) {\n\t\tif (this._dom.classList.contains(name) != !!toggler) {\n\t\t\tthis._dom.classList.toggle(name);\n\t\t};\n\t} else {\n\t\t// firefox will trigger a change if adding existing class\n\t\tif (!this._dom.classList.contains(name)) { this._dom.classList.add(name) };\n\t};\n\treturn this;\n};\n\n/*\n\tRemove specified flag from node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.unflag = function (name){\n\tthis._dom.classList.remove(name);\n\treturn this;\n};\n\n/*\n\tToggle specified flag on node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.toggleFlag = function (name){\n\tthis._dom.classList.toggle(name);\n\treturn this;\n};\n\n/*\n\tCheck whether current node has specified flag\n\t@return {bool}\n\t*/\n\nImba.Tag.prototype.hasFlag = function (name){\n\treturn this._dom.classList.contains(name);\n};\n\n\nImba.Tag.prototype.flagIf = function (flag,bool){\n\tvar f = this._flags_ || (this._flags_ = {});\n\tlet prev = f[flag];\n\t\n\tif (bool && !prev) {\n\t\tthis._dom.classList.add(flag);\n\t\tf[flag] = true;\n\t} else if (prev && !bool) {\n\t\tthis._dom.classList.remove(flag);\n\t\tf[flag] = false;\n\t};\n\t\n\treturn this;\n};\n\n/*\n\tSet/update a named flag. It remembers the previous\n\tvalue of the flag, and removes it before setting the new value.\n\n\t\tnode.setFlag('type','todo')\n\t\tnode.setFlag('type','project')\n\t\t# todo is removed, project is added.\n\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.setFlag = function (name,value){\n\tlet flags = this._namedFlags_ || (this._namedFlags_ = {});\n\tlet prev = flags[name];\n\tif (prev != value) {\n\t\tif (prev) { this.unflag(prev) };\n\t\tif (value) { this.flag(value) };\n\t\tflags[name] = value;\n\t};\n\treturn this;\n};\n\n\n/*\n\tGet the scheduler for this node. A new scheduler will be created\n\tif it does not already exist.\n\n\t@return {Imba.Scheduler}\n\t*/\n\nImba.Tag.prototype.scheduler = function (){\n\treturn (this._scheduler == null) ? (this._scheduler = new Imba.Scheduler(this)) : this._scheduler;\n};\n\n/*\n\n\tShorthand to start scheduling a node. The method will basically\n\tproxy the arguments through to scheduler.configure, and then\n\tactivate the scheduler.\n\t\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.schedule = function (options){\n\tif(options === undefined) options = {events: true};\n\tthis.scheduler().configure(options).activate();\n\treturn this;\n};\n\n/*\n\tShorthand for deactivating scheduler (if tag has one).\n\t@deprecated\n\t*/\n\nImba.Tag.prototype.unschedule = function (){\n\tif (this._scheduler) { this.scheduler().deactivate() };\n\treturn this;\n};\n\n\n/*\n\tGet the parent of current node\n\t@return {Imba.Tag} \n\t*/\n\nImba.Tag.prototype.parent = function (){\n\treturn Imba.getTagForDom(this.dom().parentNode);\n};\n\n/*\n\tGet the children of node\n\t@return {Imba.Tag[]}\n\t*/\n\nImba.Tag.prototype.children = function (sel){\n\tlet res = [];\n\tfor (let i = 0, items = iter$(this._dom.children), len = items.length, item; i < len; i++) {\n\t\titem = items[i];\n\t\tres.push(item._tag || Imba.getTagForDom(item));\n\t};\n\treturn res;\n};\n\nImba.Tag.prototype.querySelector = function (q){\n\treturn Imba.getTagForDom(this._dom.querySelector(q));\n};\n\nImba.Tag.prototype.querySelectorAll = function (q){\n\tvar items = [];\n\tfor (let i = 0, ary = iter$(this._dom.querySelectorAll(q)), len = ary.length; i < len; i++) {\n\t\titems.push(Imba.getTagForDom(ary[i]));\n\t};\n\treturn items;\n};\n\n/*\n\tCheck if this node matches a selector\n\t@return {Boolean}\n\t*/\n\nImba.Tag.prototype.matches = function (sel){\n\tvar fn;\n\tif (sel instanceof Function) {\n\t\treturn sel(this);\n\t};\n\t\n\tif (sel.query instanceof Function) { sel = sel.query() };\n\tif (fn = (this._dom.matches || this._dom.matchesSelector || this._dom.webkitMatchesSelector || this._dom.msMatchesSelector || this._dom.mozMatchesSelector)) {\n\t\treturn fn.call(this._dom,sel);\n\t};\n};\n\n/*\n\tGet the first element matching supplied selector / filter\n\ttraversing upwards, but including the node itself.\n\t@return {Imba.Tag}\n\t*/\n\nImba.Tag.prototype.closest = function (sel){\n\treturn Imba.getTagForDom(this._dom.closest(sel));\n};\n\n/*\n\tCheck if node contains other node\n\t@return {Boolean} \n\t*/\n\nImba.Tag.prototype.contains = function (node){\n\treturn this.dom().contains(node._dom || node);\n};\n\n\n/*\n\tShorthand for console.log on elements\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.log = function (){\n\tvar $0 = arguments, i = $0.length;\n\tvar args = new Array(i>0 ? i : 0);\n\twhile(i>0) args[i-1] = $0[--i];\n\targs.unshift(console);\n\tFunction.prototype.call.apply(console.log,args);\n\treturn this;\n};\n\nImba.Tag.prototype.css = function (key,val){\n\tif (key instanceof Object) {\n\t\tfor (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){\n\t\t\tk = keys[i];v = key[k];this.css(k,v);\n\t\t};\n\t\treturn this;\n\t};\n\t\n\tvar name = Imba.CSSKeyMap[key] || key;\n\t\n\tif (val == null) {\n\t\tthis.dom().style.removeProperty(name);\n\t} else if (val == undefined && arguments.length == 1) {\n\t\treturn this.dom().style[name];\n\t} else {\n\t\tif ((typeof val=='number'||val instanceof Number) && name.match(/width|height|left|right|top|bottom/)) {\n\t\t\tthis.dom().style[name] = val + \"px\";\n\t\t} else {\n\t\t\tthis.dom().style[name] = val;\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.Tag.prototype.setStyle = function (style){\n\treturn this.setAttribute('style',style);\n};\n\nImba.Tag.prototype.style = function (){\n\treturn this.getAttribute('style');\n};\n\n/*\n\tTrigger an event from current node. Dispatched through the Imba event manager.\n\tTo dispatch actual dom events, use dom.dispatchEvent instead.\n\n\t@return {Imba.Event}\n\t*/\n\nImba.Tag.prototype.trigger = function (name,data){\n\tif(data === undefined) data = {};\n\treturn true && Imba.Events.trigger(name,this,{data: data});\n};\n\n/*\n\tFocus on current node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.focus = function (){\n\tthis.dom().focus();\n\treturn this;\n};\n\n/*\n\tRemove focus from current node\n\t@return {self}\n\t*/\n\nImba.Tag.prototype.blur = function (){\n\tthis.dom().blur();\n\treturn this;\n};\n\nImba.Tag.prototype.toString = function (){\n\treturn this.dom().outerHTML;\n};\n\n\nImba.Tag.prototype.initialize = Imba.Tag;\n\nImba.SVGTag = function SVGTag(){ return Imba.Tag.apply(this,arguments) };\n\nImba.subclass(Imba.SVGTag,Imba.Tag);\nImba.SVGTag.namespaceURI = function (){\n\treturn \"http://www.w3.org/2000/svg\";\n};\n\nImba.SVGTag.buildNode = function (){\n\tvar dom = Imba.document().createElementNS(this.namespaceURI(),this._nodeType);\n\tif (this._classes) {\n\t\tvar cls = this._classes.join(\" \");\n\t\tif (cls) { dom.className.baseVal = cls };\n\t};\n\treturn dom;\n};\n\nImba.SVGTag.inherit = function (child){\n\tchild._protoDom = null;\n\t\n\tif (Imba.indexOf(child._name,Imba.SVG_TAGS) >= 0 || this == Imba.SVGTag) {\n\t\tchild._nodeType = child._name;\n\t\treturn child._classes = [];\n\t} else {\n\t\tchild._nodeType = this._nodeType;\n\t\tvar className = \"_\" + child._name.replace(/_/g,'-');\n\t\treturn child._classes = (this._classes || []).concat(className);\n\t};\n};\n\nImba.HTML_TAGS = \"a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr\".split(\" \");\nImba.HTML_TAGS_UNSAFE = \"article aside header section\".split(\" \");\nImba.SVG_TAGS = \"circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan image\".split(\" \");\n\nImba.HTML_ATTRS = {\n\ta: \"href target hreflang media download rel type\",\n\tform: \"method action enctype autocomplete target\",\n\tbutton: \"autofocus type\",\n\tinput: \"accept disabled form list max maxlength min pattern required size step type\",\n\tlabel: \"accesskey for form\",\n\timg: \"src srcset\",\n\tlink: \"rel type href media\",\n\tiframe: \"referrerpolicy src srcdoc sandbox\",\n\tmeta: \"property content charset desc\",\n\toptgroup: \"label\",\n\toption: \"label\",\n\toutput: \"for form\",\n\tobject: \"type data width height\",\n\tparam: \"name value\",\n\tprogress: \"max\",\n\tscript: \"src type async defer crossorigin integrity nonce language\",\n\tselect: \"size form multiple\",\n\ttextarea: \"rows cols\"\n};\n\n\nImba.HTML_PROPS = {\n\tinput: \"autofocus autocomplete autocorrect value placeholder required disabled multiple checked readOnly\",\n\ttextarea: \"autofocus autocomplete autocorrect value placeholder required disabled multiple checked readOnly\",\n\tform: \"novalidate\",\n\tfieldset: \"disabled\",\n\tbutton: \"disabled\",\n\tselect: \"autofocus disabled required\",\n\toption: \"disabled selected value\",\n\toptgroup: \"disabled\",\n\tprogress: \"value\",\n\tfieldset: \"disabled\",\n\tcanvas: \"width height\"\n};\n\nfunction extender(obj,sup){\n\tfor (let v, i = 0, keys = Object.keys(sup), l = keys.length, k; i < l; i++){\n\t\tk = keys[i];v = sup[k];(obj[k] == null) ? (obj[k] = v) : obj[k];\n\t};\n\t\n\tobj.prototype = Object.create(sup.prototype);\n\tobj.__super__ = obj.prototype.__super__ = sup.prototype;\n\tobj.prototype.constructor = obj;\n\tif (sup.inherit) { sup.inherit(obj) };\n\treturn obj;\n};\n\nfunction Tag(){\n\treturn function(dom,ctx) {\n\t\tthis.initialize(dom,ctx);\n\t\treturn this;\n\t};\n};\n\nfunction TagSpawner(type){\n\treturn function(zone) { return type.build(zone); };\n};\n\n\nImba.Tags = function Tags(){\n\tthis;\n};\n\nImba.Tags.prototype.__clone = function (ns){\n\tvar clone = Object.create(this);\n\tclone._parent = this;\n\treturn clone;\n};\n\nImba.Tags.prototype.ns = function (name){\n\treturn this['_' + name.toUpperCase()] || this.defineNamespace(name);\n};\n\nImba.Tags.prototype.defineNamespace = function (name){\n\tvar clone = Object.create(this);\n\tclone._parent = this;\n\tclone._ns = name;\n\tthis['_' + name.toUpperCase()] = clone;\n\treturn clone;\n};\n\nImba.Tags.prototype.baseType = function (name,ns){\n\treturn (Imba.indexOf(name,Imba.HTML_TAGS) >= 0) ? 'element' : 'div';\n};\n\nImba.Tags.prototype.defineTag = function (fullName,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = '';\n\tif(supr==undefined) supr = '';\n\tif (body && body._nodeType) {\n\t\tsupr = body;\n\t\tbody = null;\n\t};\n\t\n\tif (this[fullName]) {\n\t\tconsole.log(\"tag already exists?\",fullName);\n\t};\n\t\n\t// if it is namespaced\n\tvar ns;\n\tvar name = fullName;\n\tlet nsidx = name.indexOf(':');\n\tif (nsidx >= 0) {\n\t\tns = fullName.substr(0,nsidx);\n\t\tname = fullName.substr(nsidx + 1);\n\t\tif (ns == 'svg' && !supr) {\n\t\t\tsupr = 'svg:element';\n\t\t};\n\t};\n\t\n\tsupr || (supr = this.baseType(fullName));\n\t\n\tlet supertype = ((typeof supr=='string'||supr instanceof String)) ? this.findTagType(supr) : supr;\n\tlet tagtype = Tag();\n\t\n\ttagtype._name = name;\n\ttagtype._flagName = null;\n\t\n\tif (name[0] == '#') {\n\t\tImba.SINGLETONS[name.slice(1)] = tagtype;\n\t\tthis[name] = tagtype;\n\t} else if (name[0] == name[0].toUpperCase()) {\n\t\ttagtype._flagName = name;\n\t} else {\n\t\ttagtype._flagName = \"_\" + fullName.replace(/[_\\:]/g,'-');\n\t\tthis[fullName] = tagtype;\n\t};\n\t\n\textender(tagtype,supertype);\n\t\n\tif (body) {\n\t\tbody.call(tagtype,tagtype,tagtype.TAGS || this);\n\t\tif (tagtype.defined) { tagtype.defined() };\n\t\tthis.optimizeTag(tagtype);\n\t};\n\treturn tagtype;\n};\n\nImba.Tags.prototype.defineSingleton = function (name,supr,body){\n\treturn this.defineTag(name,supr,body);\n};\n\nImba.Tags.prototype.extendTag = function (name,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = '';\n\tif(supr==undefined) supr = '';\n\tvar klass = (((typeof name=='string'||name instanceof String)) ? this.findTagType(name) : name);\n\t// allow for private tags here as well?\n\tif (body) { body && body.call(klass,klass,klass.prototype) };\n\tif (klass.extended) { klass.extended() };\n\tthis.optimizeTag(klass);\n\treturn klass;\n};\n\nImba.Tags.prototype.optimizeTag = function (tagtype){\n\tvar prototype_;\n\treturn (prototype_ = tagtype.prototype) && prototype_.optimizeTagStructure  &&  prototype_.optimizeTagStructure();\n};\n\nImba.Tags.prototype.findTagType = function (type){\n\tvar attrs, props;\n\tlet klass = this[type];\n\tif (!klass) {\n\t\tif (type.substr(0,4) == 'svg:') {\n\t\t\tklass = this.defineTag(type,'svg:element');\n\t\t} else if (Imba.HTML_TAGS.indexOf(type) >= 0) {\n\t\t\tklass = this.defineTag(type,'element');\n\t\t\t\n\t\t\tif (attrs = Imba.HTML_ATTRS[type]) {\n\t\t\t\tfor (let i = 0, items = iter$(attrs.split(\" \")), len = items.length; i < len; i++) {\n\t\t\t\t\tImba.attr(klass,items[i]);\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (props = Imba.HTML_PROPS[type]) {\n\t\t\t\tfor (let i = 0, items = iter$(props.split(\" \")), len = items.length; i < len; i++) {\n\t\t\t\t\tImba.attr(klass,items[i],{dom: true});\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\treturn klass;\n};\n\nImba.Tags.prototype.createElement = function (name,owner){\n\tvar typ;\n\tif (name instanceof Function) {\n\t\ttyp = name;\n\t} else {\n\t\tif (null) {};\n\t\ttyp = this.findTagType(name);\n\t};\n\treturn typ.build(owner);\n};\n\n\nImba.createElement = function (name,ctx,ref,pref){\n\tvar type = name;\n\tvar parent;\n\tif (name instanceof Function) {\n\t\ttype = name;\n\t} else {\n\t\tif (null) {};\n\t\ttype = Imba.TAGS.findTagType(name);\n\t};\n\t\n\tif (ctx instanceof TagMap) {\n\t\tparent = ctx.par$;\n\t} else if (pref instanceof Imba.Tag) {\n\t\tparent = pref;\n\t} else {\n\t\tparent = (ctx && pref != undefined) ? ctx[pref] : ((ctx && ctx._tag || ctx));\n\t};\n\t\n\tvar node = type.build(parent);\n\t\n\tif (ctx instanceof TagMap) {\n\t\tctx.i$++;\n\t\tnode.$key = ref;\n\t};\n\t\n\t// node:$ref = ref if ref\n\t// context:i$++ # only if it is not an array?\n\tif (ctx && ref != undefined) {\n\t\tctx[ref] = node;\n\t};\n\t\n\treturn node;\n};\n\nImba.createTagCache = function (owner){\n\tvar item = [];\n\titem._tag = owner;\n\treturn item;\n\t\n\tvar par = ((this.pref() != undefined) ? this.ctx()[this.pref()] : this.ctx()._tag);\n\tvar node = new TagMap(this.ctx(),this.ref(),par);\n\tthis.ctx()[this.ref()] = node;\n\treturn node;\n};\n\nImba.createTagMap = function (ctx,ref,pref){\n\tvar par = ((pref != undefined) ? pref : ctx._tag);\n\tvar node = new TagMap(ctx,ref,par);\n\tctx[ref] = node;\n\treturn node;\n};\n\nImba.createTagList = function (ctx,ref,pref){\n\tvar node = [];\n\tnode._type = 4;\n\tnode._tag = ((pref != undefined) ? pref : ctx._tag);\n\tctx[ref] = node;\n\treturn node;\n};\n\nImba.createTagLoopResult = function (ctx,ref,pref){\n\tvar node = [];\n\tnode._type = 5;\n\tnode.cache = {i$: 0};\n\treturn node;\n};\n\n// use array instead?\nfunction TagCache(owner){\n\tthis._tag = owner;\n\tthis;\n};\nTagCache.build = function (owner){\n\tvar item = [];\n\titem._tag = owner;\n\treturn item;\n};\n\n\n\nfunction TagMap(cache,ref,par){\n\tthis.cache$ = cache;\n\tthis.key$ = ref;\n\tthis.par$ = par;\n\tthis.i$ = 0;\n\t// self:curr$ = self:$iternew()\n\t// self:next$ = self:$iternew()\n};\n\nTagMap.prototype.$iter = function (){\n\tvar item = [];\n\titem._type = 5;\n\titem.cache = this;\n\treturn item;\n};\n\nTagMap.prototype.$prune = function (items){\n\tlet cache = this.cache$;\n\tlet key = this.key$;\n\tlet clone = new TagMap(cache,key,this.par$);\n\tfor (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {\n\t\titem = ary[i];\n\t\tclone[item.key$] = item;\n\t};\n\tclone.i$ = items.length;\n\treturn cache[key] = clone;\n};\n\nImba.TagMap = TagMap;\nImba.TagCache = TagCache;\nImba.SINGLETONS = {};\nImba.TAGS = new Imba.Tags();\nImba.TAGS.element = Imba.TAGS.htmlelement = Imba.Tag;\nImba.TAGS['svg:element'] = Imba.SVGTag;\n\nImba.defineTag = function (name,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = '';\n\tif(supr==undefined) supr = '';\n\treturn Imba.TAGS.defineTag(name,supr,body);\n};\n\nImba.defineSingletonTag = function (id,supr,body){\n\tif(body==undefined && typeof supr == 'function') body = supr,supr = 'div';\n\tif(supr==undefined) supr = 'div';\n\treturn Imba.TAGS.defineTag(this.name(),supr,body);\n};\n\nImba.extendTag = function (name,body){\n\treturn Imba.TAGS.extendTag(name,body);\n};\n\nImba.getTagSingleton = function (id){\n\tvar klass;\n\tvar dom,node;\n\t\n\tif (klass = Imba.SINGLETONS[id]) {\n\t\tif (klass && klass.Instance) { return klass.Instance };\n\t\t\n\t\t// no instance - check for element\n\t\tif (dom = Imba.document().getElementById(id)) {\n\t\t\t// we have a live instance - when finding it through a selector we should awake it, no?\n\t\t\t// console.log('creating the singleton from existing node in dom?',id,type)\n\t\t\tnode = klass.Instance = new klass(dom);\n\t\t\tnode.awaken(dom); // should only awaken\n\t\t\treturn node;\n\t\t};\n\t\t\n\t\tdom = klass.createNode();\n\t\tdom.id = id;\n\t\tnode = klass.Instance = new klass(dom);\n\t\tnode.end().awaken(dom);\n\t\treturn node;\n\t} else if (dom = Imba.document().getElementById(id)) {\n\t\treturn Imba.getTagForDom(dom);\n\t};\n};\n\nvar svgSupport = typeof SVGElement !== 'undefined';\n\n// shuold be phased out\nImba.getTagForDom = function (dom){\n\tif (!dom) { return null };\n\tif (dom._dom) { return dom }; // could use inheritance instead\n\tif (dom._tag) { return dom._tag };\n\tif (!dom.nodeName) { return null };\n\t\n\tvar name = dom.nodeName.toLowerCase();\n\tvar type = name;\n\tvar ns = Imba.TAGS; //  svgSupport and dom isa SVGElement ? Imba.TAGS:_SVG : Imba.TAGS\n\t\n\tif (dom.id && Imba.SINGLETONS[dom.id]) {\n\t\treturn Imba.getTagSingleton(dom.id);\n\t};\n\t\n\tif (svgSupport && (dom instanceof SVGElement)) {\n\t\ttype = ns.findTagType(\"svg:\" + name);\n\t} else if (Imba.HTML_TAGS.indexOf(name) >= 0) {\n\t\ttype = ns.findTagType(name);\n\t} else {\n\t\ttype = Imba.Tag;\n\t};\n\t// if ns.@nodeNames.indexOf(name) >= 0\n\t//\ttype = ns.findTagType(name)\n\t\n\treturn new type(dom,null).awaken(dom);\n};\n\n// deprecate\nImba.generateCSSPrefixes = function (){\n\tvar styles = window.getComputedStyle(document.documentElement,'');\n\t\n\tfor (let i = 0, items = iter$(styles), len = items.length, prefixed; i < len; i++) {\n\t\tprefixed = items[i];\n\t\tvar unprefixed = prefixed.replace(/^-(webkit|ms|moz|o|blink)-/,'');\n\t\tvar camelCase = unprefixed.replace(/-(\\w)/g,function(m,a) { return a.toUpperCase(); });\n\t\t\n\t\t// if there exists an unprefixed version -- always use this\n\t\tif (prefixed != unprefixed) {\n\t\t\tif (styles.hasOwnProperty(unprefixed)) { continue; };\n\t\t};\n\t\t\n\t\t// register the prefixes\n\t\tImba.CSSKeyMap[unprefixed] = Imba.CSSKeyMap[camelCase] = prefixed;\n\t};\n\treturn;\n};\n\nif (true) {\n\tif (document) { Imba.generateCSSPrefixes() };\n\t\n\t// Ovverride classList\n\tif (document && !document.documentElement.classList) {\n\t\tImba.extendTag('element', function(tag){\n\t\t\t\n\t\t\ttag.prototype.hasFlag = function (ref){\n\t\t\t\treturn new RegExp('(^|\\\\s)' + ref + '(\\\\s|$)').test(this._dom.className);\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.addFlag = function (ref){\n\t\t\t\tif (this.hasFlag(ref)) { return this };\n\t\t\t\tthis._dom.className += (this._dom.className ? ' ' : '') + ref;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.unflag = function (ref){\n\t\t\t\tif (!this.hasFlag(ref)) { return this };\n\t\t\t\tvar regex = new RegExp('(^|\\\\s)*' + ref + '(\\\\s|$)*','g');\n\t\t\t\tthis._dom.className = this._dom.className.replace(regex,'');\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.toggleFlag = function (ref){\n\t\t\t\treturn this.hasFlag(ref) ? this.unflag(ref) : this.flag(ref);\n\t\t\t};\n\t\t\t\n\t\t\ttag.prototype.flag = function (ref,bool){\n\t\t\t\tif (arguments.length == 2 && !!bool === false) {\n\t\t\t\t\treturn this.unflag(ref);\n\t\t\t\t};\n\t\t\t\treturn this.addFlag(ref);\n\t\t\t};\n\t\t});\n\t};\n};\n\nImba.Tag;\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/tag.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/dom/touch.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/dom/touch.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ../imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\n// Imba.Touch\n// Began\tA finger touched the screen.\n// Moved\tA finger moved on the screen.\n// Stationary\tA finger is touching the screen but hasn't moved.\n// Ended\tA finger was lifted from the screen. This is the final phase of a touch.\n// Canceled The system cancelled tracking for the touch.\n\n/*\nConsolidates mouse and touch events. Touch objects persist across a touch,\nfrom touchstart until end/cancel. When a touch starts, it will traverse\ndown from the innermost target, until it finds a node that responds to\nontouchstart. Unless the touch is explicitly redirected, the touch will\ncall ontouchmove and ontouchend / ontouchcancel on the responder when appropriate.\n\n\ttag draggable\n\t\t# called when a touch starts\n\t\tdef ontouchstart touch\n\t\t\tflag 'dragging'\n\t\t\tself\n\t\t\n\t\t# called when touch moves - same touch object\n\t\tdef ontouchmove touch\n\t\t\t# move the node with touch\n\t\t\tcss top: touch.dy, left: touch.dx\n\t\t\n\t\t# called when touch ends\n\t\tdef ontouchend touch\n\t\t\tunflag 'dragging'\n\n@iname touch\n*/\n\nImba.Touch = function Touch(event,pointer){\n\t// @native  = false\n\tthis.setEvent(event);\n\tthis.setData({});\n\tthis.setActive(true);\n\tthis._button = event && event.button || 0;\n\tthis._suppress = false; // deprecated\n\tthis._captured = false;\n\tthis.setBubble(false);\n\tpointer = pointer;\n\tthis.setUpdates(0);\n\treturn this;\n};\n\nImba.Touch.LastTimestamp = 0;\nImba.Touch.TapTimeout = 50;\n\n// var lastNativeTouchTimeout = 50\n\nvar touches = [];\nvar count = 0;\nvar identifiers = {};\n\nImba.Touch.count = function (){\n\treturn count;\n};\n\nImba.Touch.lookup = function (item){\n\treturn item && (item.__touch__ || identifiers[item.identifier]);\n};\n\nImba.Touch.release = function (item,touch){\n\tvar v_, $1;\n\t(((v_ = identifiers[item.identifier]),delete identifiers[item.identifier], v_));\n\t((($1 = item.__touch__),delete item.__touch__, $1));\n\treturn;\n};\n\nImba.Touch.ontouchstart = function (e){\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (this.lookup(t)) { continue; };\n\t\tvar touch = identifiers[t.identifier] = new this(e); // (e)\n\t\tt.__touch__ = touch;\n\t\ttouches.push(touch);\n\t\tcount++;\n\t\ttouch.touchstart(e,t);\n\t};\n\treturn this;\n};\n\nImba.Touch.ontouchmove = function (e){\n\tvar touch;\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (touch = this.lookup(t)) {\n\t\t\ttouch.touchmove(e,t);\n\t\t};\n\t};\n\t\n\treturn this;\n};\n\nImba.Touch.ontouchend = function (e){\n\tvar touch;\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (touch = this.lookup(t)) {\n\t\t\ttouch.touchend(e,t);\n\t\t\tthis.release(t,touch);\n\t\t\tcount--;\n\t\t};\n\t};\n\t\n\t// e.preventDefault\n\t// not always supported!\n\t// touches = touches.filter(||)\n\treturn this;\n};\n\nImba.Touch.ontouchcancel = function (e){\n\tvar touch;\n\tfor (let i = 0, items = iter$(e.changedTouches), len = items.length, t; i < len; i++) {\n\t\tt = items[i];\n\t\tif (touch = this.lookup(t)) {\n\t\t\ttouch.touchcancel(e,t);\n\t\t\tthis.release(t,touch);\n\t\t\tcount--;\n\t\t};\n\t};\n\treturn this;\n};\n\nImba.Touch.onmousedown = function (e){\n\treturn this;\n};\n\nImba.Touch.onmousemove = function (e){\n\treturn this;\n};\n\nImba.Touch.onmouseup = function (e){\n\treturn this;\n};\n\n\nImba.Touch.prototype.phase = function(v){ return this._phase; }\nImba.Touch.prototype.setPhase = function(v){ this._phase = v; return this; };\nImba.Touch.prototype.active = function(v){ return this._active; }\nImba.Touch.prototype.setActive = function(v){ this._active = v; return this; };\nImba.Touch.prototype.event = function(v){ return this._event; }\nImba.Touch.prototype.setEvent = function(v){ this._event = v; return this; };\nImba.Touch.prototype.pointer = function(v){ return this._pointer; }\nImba.Touch.prototype.setPointer = function(v){ this._pointer = v; return this; };\nImba.Touch.prototype.target = function(v){ return this._target; }\nImba.Touch.prototype.setTarget = function(v){ this._target = v; return this; };\nImba.Touch.prototype.handler = function(v){ return this._handler; }\nImba.Touch.prototype.setHandler = function(v){ this._handler = v; return this; };\nImba.Touch.prototype.updates = function(v){ return this._updates; }\nImba.Touch.prototype.setUpdates = function(v){ this._updates = v; return this; };\nImba.Touch.prototype.suppress = function(v){ return this._suppress; }\nImba.Touch.prototype.setSuppress = function(v){ this._suppress = v; return this; };\nImba.Touch.prototype.data = function(v){ return this._data; }\nImba.Touch.prototype.setData = function(v){ this._data = v; return this; };\nImba.Touch.prototype.__bubble = {chainable: true,name: 'bubble'};\nImba.Touch.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }\nImba.Touch.prototype.setBubble = function(v){ this._bubble = v; return this; };\nImba.Touch.prototype.timestamp = function(v){ return this._timestamp; }\nImba.Touch.prototype.setTimestamp = function(v){ this._timestamp = v; return this; };\n\nImba.Touch.prototype.gestures = function(v){ return this._gestures; }\nImba.Touch.prototype.setGestures = function(v){ this._gestures = v; return this; };\n\n/*\n\t@internal\n\t@constructor\n\t*/\n\nImba.Touch.prototype.capture = function (){\n\tthis._captured = true;\n\tthis._event && this._event.stopPropagation();\n\tif (!this._selblocker) {\n\t\tthis._selblocker = function(e) { return e.preventDefault(); };\n\t\tImba.document().addEventListener('selectstart',this._selblocker,true);\n\t};\n\treturn this;\n};\n\nImba.Touch.prototype.isCaptured = function (){\n\treturn !!this._captured;\n};\n\n/*\n\tExtend the touch with a plugin / gesture. \n\tAll events (touchstart,move etc) for the touch\n\twill be triggered on the plugins in the order they\n\tare added.\n\t*/\n\nImba.Touch.prototype.extend = function (plugin){\n\t// console.log \"added gesture!!!\"\n\tthis._gestures || (this._gestures = []);\n\tthis._gestures.push(plugin);\n\treturn this;\n};\n\n/*\n\tRedirect touch to specified target. ontouchstart will always be\n\tcalled on the new target.\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.redirect = function (target){\n\tthis._redirect = target;\n\treturn this;\n};\n\n/*\n\tSuppress the default behaviour. Will call preventDefault for\n\tall native events that are part of the touch.\n\t*/\n\nImba.Touch.prototype.suppress = function (){\n\t// collision with the suppress property\n\tthis._active = false;\n\t\n\treturn this;\n};\n\nImba.Touch.prototype.setSuppress = function (value){\n\tconsole.warn('Imba.Touch#suppress= is deprecated');\n\tthis._supress = value;\n\tthis;\n\treturn this;\n};\n\nImba.Touch.prototype.touchstart = function (e,t){\n\tthis._event = e;\n\tthis._touch = t;\n\tthis._button = 0;\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.began();\n\tthis.update();\n\tif (e && this.isCaptured()) { e.preventDefault() };\n\treturn this;\n};\n\nImba.Touch.prototype.touchmove = function (e,t){\n\tthis._event = e;\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.update();\n\tif (e && this.isCaptured()) { e.preventDefault() };\n\treturn this;\n};\n\nImba.Touch.prototype.touchend = function (e,t){\n\tthis._event = e;\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.ended();\n\t\n\tImba.Touch.LastTimestamp = e.timeStamp;\n\t\n\tif (this._maxdr < 20) {\n\t\tvar tap = new Imba.Event(e);\n\t\ttap.setType('tap');\n\t\ttap.process();\n\t\tif (tap._responder) { e.preventDefault() };\n\t};\n\t\n\tif (e && this.isCaptured()) {\n\t\te.preventDefault();\n\t};\n\t\n\treturn this;\n};\n\nImba.Touch.prototype.touchcancel = function (e,t){\n\treturn this.cancel();\n};\n\nImba.Touch.prototype.mousedown = function (e,t){\n\tvar self = this;\n\tself._event = e;\n\tself._button = e.button;\n\tself._x = t.clientX;\n\tself._y = t.clientY;\n\tself.began();\n\tself.update();\n\tself._mousemove = function(e) { return self.mousemove(e,e); };\n\tImba.document().addEventListener('mousemove',self._mousemove,true);\n\treturn self;\n};\n\nImba.Touch.prototype.mousemove = function (e,t){\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis._event = e;\n\tif (this.isCaptured()) { e.preventDefault() };\n\tthis.update();\n\tthis.move();\n\treturn this;\n};\n\nImba.Touch.prototype.mouseup = function (e,t){\n\tthis._x = t.clientX;\n\tthis._y = t.clientY;\n\tthis.ended();\n\treturn this;\n};\n\nImba.Touch.prototype.idle = function (){\n\treturn this.update();\n};\n\nImba.Touch.prototype.began = function (){\n\tthis._timestamp = Date.now();\n\tthis._maxdr = this._dr = 0;\n\tthis._x0 = this._x;\n\tthis._y0 = this._y;\n\t\n\tvar dom = this.event().target;\n\tvar node = null;\n\t\n\tthis._sourceTarget = dom && Imba.getTagForDom(dom);\n\t\n\twhile (dom){\n\t\tnode = Imba.getTagForDom(dom);\n\t\tif (node && node.ontouchstart) {\n\t\t\tthis._bubble = false;\n\t\t\tthis.setTarget(node);\n\t\t\tthis.target().ontouchstart(this);\n\t\t\tif (!this._bubble) { break; };\n\t\t};\n\t\tdom = dom.parentNode;\n\t};\n\t\n\tthis._updates++;\n\treturn this;\n};\n\nImba.Touch.prototype.update = function (){\n\tvar target_;\n\tif (!this._active || this._cancelled) { return this };\n\t\n\tvar dr = Math.sqrt(this.dx() * this.dx() + this.dy() * this.dy());\n\tif (dr > this._dr) { this._maxdr = dr };\n\tthis._dr = dr;\n\t\n\t// catching a touch-redirect?!?\n\tif (this._redirect) {\n\t\tif (this._target && this._target.ontouchcancel) {\n\t\t\tthis._target.ontouchcancel(this);\n\t\t};\n\t\tthis.setTarget(this._redirect);\n\t\tthis._redirect = null;\n\t\tif (this.target().ontouchstart) { this.target().ontouchstart(this) };\n\t\tif (this._redirect) { return this.update() }; // possibly redirecting again\n\t};\n\t\n\t\n\tthis._updates++;\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length; i < len; i++) {\n\t\t\titems[i].ontouchupdate(this);\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchupdate  &&  target_.ontouchupdate(this);\n\tif (this._redirect) this.update();\n\treturn this;\n};\n\nImba.Touch.prototype.move = function (){\n\tvar target_;\n\tif (!this._active || this._cancelled) { return this };\n\t\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length, g; i < len; i++) {\n\t\t\tg = items[i];\n\t\t\tif (g.ontouchmove) { g.ontouchmove(this,this._event) };\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchmove  &&  target_.ontouchmove(this,this._event);\n\treturn this;\n};\n\nImba.Touch.prototype.ended = function (){\n\tvar target_;\n\tif (!this._active || this._cancelled) { return this };\n\t\n\tthis._updates++;\n\t\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length; i < len; i++) {\n\t\t\titems[i].ontouchend(this);\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchend  &&  target_.ontouchend(this);\n\tthis.cleanup_();\n\treturn this;\n};\n\nImba.Touch.prototype.cancel = function (){\n\tif (!this._cancelled) {\n\t\tthis._cancelled = true;\n\t\tthis.cancelled();\n\t\tthis.cleanup_();\n\t};\n\treturn this;\n};\n\nImba.Touch.prototype.cancelled = function (){\n\tvar target_;\n\tif (!this._active) { return this };\n\t\n\tthis._cancelled = true;\n\tthis._updates++;\n\t\n\tif (this._gestures) {\n\t\tfor (let i = 0, items = iter$(this._gestures), len = items.length, g; i < len; i++) {\n\t\t\tg = items[i];\n\t\t\tif (g.ontouchcancel) { g.ontouchcancel(this) };\n\t\t};\n\t};\n\t\n\t(target_ = this.target()) && target_.ontouchcancel  &&  target_.ontouchcancel(this);\n\treturn this;\n};\n\nImba.Touch.prototype.cleanup_ = function (){\n\tif (this._mousemove) {\n\t\tImba.document().removeEventListener('mousemove',this._mousemove,true);\n\t\tthis._mousemove = null;\n\t};\n\t\n\tif (this._selblocker) {\n\t\tImba.document().removeEventListener('selectstart',this._selblocker,true);\n\t\tthis._selblocker = null;\n\t};\n\t\n\treturn this;\n};\n\n/*\n\tThe absolute distance the touch has moved from starting position \n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.dr = function (){\n\treturn this._dr;\n};\n\n/*\n\tThe distance the touch has moved horizontally\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.dx = function (){\n\treturn this._x - this._x0;\n};\n\n/*\n\tThe distance the touch has moved vertically\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.dy = function (){\n\treturn this._y - this._y0;\n};\n\n/*\n\tInitial horizontal position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.x0 = function (){\n\treturn this._x0;\n};\n\n/*\n\tInitial vertical position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.y0 = function (){\n\treturn this._y0;\n};\n\n/*\n\tHorizontal position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.x = function (){\n\treturn this._x;\n};\n\n/*\n\tVertical position of touch\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.y = function (){\n\treturn this._y;\n};\n\n/*\n\tHorizontal position of touch relative to target\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.tx = function (){\n\tthis._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());\n\treturn this._x - this._targetBox.left;\n};\n\n/*\n\tVertical position of touch relative to target\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.ty = function (){\n\tthis._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());\n\treturn this._y - this._targetBox.top;\n};\n\n/*\n\tButton pressed in this touch. Native touches defaults to left-click (0)\n\t@return {Number}\n\t*/\n\nImba.Touch.prototype.button = function (){\n\treturn this._button;\n}; // @pointer ? @pointer.button : 0\n\nImba.Touch.prototype.sourceTarget = function (){\n\treturn this._sourceTarget;\n};\n\nImba.Touch.prototype.elapsed = function (){\n\treturn Date.now() - this._timestamp;\n};\n\n\nImba.TouchGesture = function TouchGesture(){ };\n\nImba.TouchGesture.prototype.__active = {'default': false,name: 'active'};\nImba.TouchGesture.prototype.active = function(v){ return this._active; }\nImba.TouchGesture.prototype.setActive = function(v){ this._active = v; return this; }\nImba.TouchGesture.prototype._active = false;\n\nImba.TouchGesture.prototype.ontouchstart = function (e){\n\treturn this;\n};\n\nImba.TouchGesture.prototype.ontouchupdate = function (e){\n\treturn this;\n};\n\nImba.TouchGesture.prototype.ontouchend = function (e){\n\treturn this;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/dom/touch.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/imba.imba":
/*!**********************************************!*\
  !*** ./node_modules/imba/src/imba/imba.imba ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\nImba is the namespace for all runtime related utilities\n@namespace\n*/\n\nvar Imba = {VERSION: '1.3.3'};\n\n/*\n\nLight wrapper around native setTimeout that expects the block / function\nas last argument (instead of first). It also triggers an event to Imba\nafter the timeout to let schedulers update (to rerender etc) afterwards.\n\n*/\n\nImba.setTimeout = function (delay,block){\n\treturn setTimeout(function() {\n\t\tblock();\n\t\treturn Imba.commit();\n\t},delay);\n};\n\n/*\n\nLight wrapper around native setInterval that expects the block / function\nas last argument (instead of first). It also triggers an event to Imba\nafter every interval to let schedulers update (to rerender etc) afterwards.\n\n*/\n\nImba.setInterval = function (interval,block){\n\treturn setInterval(block,interval);\n};\n\n/*\nClear interval with specified id\n*/\n\nImba.clearInterval = function (id){\n\treturn clearInterval(id);\n};\n\n/*\nClear timeout with specified id\n*/\n\nImba.clearTimeout = function (id){\n\treturn clearTimeout(id);\n};\n\n\nImba.subclass = function (obj,sup){\n\tfor (let k in sup){\n\t\tlet v;\n\t\tv = sup[k];if (sup.hasOwnProperty(k)) { obj[k] = v };\n\t};\n\t\n\tobj.prototype = Object.create(sup.prototype);\n\tobj.__super__ = obj.prototype.__super__ = sup.prototype;\n\tobj.prototype.initialize = obj.prototype.constructor = obj;\n\treturn obj;\n};\n\n/*\nLightweight method for making an object iterable in imbas for/in loops.\nIf the compiler cannot say for certain that a target in a for loop is an\narray, it will cache the iterable version before looping.\n\n```imba\n# this is the whole method\ndef Imba.iterable o\n\treturn o ? (o:toArray ? o.toArray : o) : []\n\nclass CustomIterable\n\tdef toArray\n\t\t[1,2,3]\n\n# will return [2,4,6]\nfor x in CustomIterable.new\n\tx * 2\n\n```\n*/\n\nImba.iterable = function (o){\n\treturn o ? ((o.toArray ? o.toArray() : o)) : [];\n};\n\n/*\nCoerces a value into a promise. If value is array it will\ncall `Promise.all(value)`, or if it is not a promise it will\nwrap the value in `Promise.resolve(value)`. Used for experimental\nawait syntax.\n@return {Promise}\n*/\n\nImba.await = function (value){\n\tif (value instanceof Array) {\n\t\tconsole.warn(\"await (Array) is deprecated - use await Promise.all(Array)\");\n\t\treturn Promise.all(value);\n\t} else if (value && value.then) {\n\t\treturn value;\n\t} else {\n\t\treturn Promise.resolve(value);\n\t};\n};\n\nvar dashRegex = /-./g;\nvar setterCache = {};\n\nImba.toCamelCase = function (str){\n\tif (str.indexOf('-') >= 0) {\n\t\treturn str.replace(dashRegex,function(m) { return m.charAt(1).toUpperCase(); });\n\t} else {\n\t\treturn str;\n\t};\n};\n\nImba.toSetter = function (str){\n\treturn setterCache[str] || (setterCache[str] = Imba.toCamelCase('set-' + str));\n};\n\nImba.indexOf = function (a,b){\n\treturn (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n};\n\nImba.len = function (a){\n\treturn a && ((a.len instanceof Function) ? a.len.call(a) : a.length) || 0;\n};\n\nImba.prop = function (scope,name,opts){\n\tif (scope.defineProperty) {\n\t\treturn scope.defineProperty(name,opts);\n\t};\n\treturn;\n};\n\nImba.attr = function (scope,name,opts){\n\tif(opts === undefined) opts = {};\n\tif (scope.defineAttribute) {\n\t\treturn scope.defineAttribute(name,opts);\n\t};\n\t\n\tlet getName = Imba.toCamelCase(name);\n\tlet setName = Imba.toCamelCase('set-' + name);\n\tlet proto = scope.prototype;\n\t\n\tif (opts.dom) {\n\t\tproto[getName] = function() { return this.dom()[name]; };\n\t\tproto[setName] = function(value) {\n\t\t\tif (value != this[name]()) {\n\t\t\t\tthis.dom()[name] = value;\n\t\t\t};\n\t\t\treturn this;\n\t\t};\n\t} else {\n\t\tproto[getName] = function() { return this.getAttribute(name); };\n\t\tproto[setName] = function(value) {\n\t\t\tthis.setAttribute(name,value);\n\t\t\treturn this;\n\t\t};\n\t};\n\treturn;\n};\n\nImba.propDidSet = function (object,property,val,prev){\n\tlet fn = property.watch;\n\tif (fn instanceof Function) {\n\t\tfn.call(object,val,prev,property);\n\t} else if ((typeof fn=='string'||fn instanceof String) && object[fn]) {\n\t\tobject[fn](val,prev,property);\n\t};\n\treturn;\n};\n\n\n// Basic events\nfunction emit__(event,args,node){\n\t// var node = cbs[event]\n\tvar prev,cb,ret;\n\t\n\twhile ((prev = node) && (node = node.next)){\n\t\tif (cb = node.listener) {\n\t\t\tif (node.path && cb[node.path]) {\n\t\t\t\tret = args ? cb[node.path].apply(cb,args) : cb[node.path]();\n\t\t\t} else {\n\t\t\t\t// check if it is a method?\n\t\t\t\tret = args ? cb.apply(node,args) : cb.call(node);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (node.times && --node.times <= 0) {\n\t\t\tprev.next = node.next;\n\t\t\tnode.listener = null;\n\t\t};\n\t};\n\treturn;\n};\n\n// method for registering a listener on object\nImba.listen = function (obj,event,listener,path){\n\tvar cbs,list,tail;\n\tcbs = obj.__listeners__ || (obj.__listeners__ = {});\n\tlist = cbs[event] || (cbs[event] = {});\n\ttail = list.tail || (list.tail = (list.next = {}));\n\ttail.listener = listener;\n\ttail.path = path;\n\tlist.tail = tail.next = {};\n\treturn tail;\n};\n\n// register a listener once\nImba.once = function (obj,event,listener){\n\tvar tail = Imba.listen(obj,event,listener);\n\ttail.times = 1;\n\treturn tail;\n};\n\n// remove a listener\nImba.unlisten = function (obj,event,cb,meth){\n\tvar node,prev;\n\tvar meta = obj.__listeners__;\n\tif (!meta) { return };\n\t\n\tif (node = meta[event]) {\n\t\twhile ((prev = node) && (node = node.next)){\n\t\t\tif (node == cb || node.listener == cb) {\n\t\t\t\tprev.next = node.next;\n\t\t\t\t// check for correct path as well?\n\t\t\t\tnode.listener = null;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\t};\n\treturn;\n};\n\n// emit event\nImba.emit = function (obj,event,params){\n\tvar cb;\n\tif (cb = obj.__listeners__) {\n\t\tif (cb[event]) { emit__(event,params,cb[event]) };\n\t\tif (cb.all) { emit__(event,[event,params],cb.all) }; // and event != 'all'\n\t};\n\treturn;\n};\n\nImba.observeProperty = function (observer,key,trigger,target,prev){\n\tif (prev && typeof prev == 'object') {\n\t\tImba.unlisten(prev,'all',observer,trigger);\n\t};\n\tif (target && typeof target == 'object') {\n\t\tImba.listen(target,'all',observer,trigger);\n\t};\n\treturn this;\n};\n\nmodule.exports = Imba;\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/imba.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/index.imba":
/*!***********************************************!*\
  !*** ./node_modules/imba/src/imba/index.imba ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! ./imba */ \"./node_modules/imba/src/imba/imba.imba\");\nvar activate = false;\nif (typeof window !== 'undefined') {\n\tif (window.Imba) {\n\t\tconsole.warn((\"Imba v\" + (window.Imba.VERSION) + \" is already loaded.\"));\n\t\tImba = window.Imba;\n\t} else {\n\t\twindow.Imba = Imba;\n\t\tactivate = true;\n\t\tif (window.define && window.define.amd) {\n\t\t\twindow.define(\"imba\",[],function() { return Imba; });\n\t\t};\n\t};\n};\n\nmodule.exports = Imba;\n\nif (true) {\n\t__webpack_require__(/*! ./scheduler */ \"./node_modules/imba/src/imba/scheduler.imba\");\n\t__webpack_require__(/*! ./dom/index */ \"./node_modules/imba/src/imba/dom/index.imba\");\n};\n\nif (true && activate) {\n\tImba.EventManager.activate();\n};\n\nif (false) {};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/index.imba?");

/***/ }),

/***/ "./node_modules/imba/src/imba/scheduler.imba":
/*!***************************************************!*\
  !*** ./node_modules/imba/src/imba/scheduler.imba ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };\nvar Imba = __webpack_require__(/*! ./imba */ \"./node_modules/imba/src/imba/imba.imba\");\n\nvar requestAnimationFrame; // very simple raf polyfill\nvar cancelAnimationFrame;\n\nif (false) {};\n\nif (true) {\n\tcancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitRequestAnimationFrame;\n\trequestAnimationFrame = window.requestAnimationFrame;\n\trequestAnimationFrame || (requestAnimationFrame = window.webkitRequestAnimationFrame);\n\trequestAnimationFrame || (requestAnimationFrame = window.mozRequestAnimationFrame);\n\trequestAnimationFrame || (requestAnimationFrame = function(blk) { return setTimeout(blk,1000 / 60); });\n};\n\nfunction Ticker(){\n\tvar self = this;\n\tself._queue = [];\n\tself._stage = -1;\n\tself._scheduled = false;\n\tself._ticker = function(e) {\n\t\tself._scheduled = false;\n\t\treturn self.tick(e);\n\t};\n\tself;\n};\n\nTicker.prototype.stage = function(v){ return this._stage; }\nTicker.prototype.setStage = function(v){ this._stage = v; return this; };\nTicker.prototype.queue = function(v){ return this._queue; }\nTicker.prototype.setQueue = function(v){ this._queue = v; return this; };\n\nTicker.prototype.add = function (item,force){\n\tif (force || this._queue.indexOf(item) == -1) {\n\t\tthis._queue.push(item);\n\t};\n\t\n\tif (!this._scheduled) { return this.schedule() };\n};\n\nTicker.prototype.tick = function (timestamp){\n\tvar items = this._queue;\n\tif (!this._ts) { this._ts = timestamp };\n\tthis._dt = timestamp - this._ts;\n\tthis._ts = timestamp;\n\tthis._queue = [];\n\tthis._stage = 1;\n\tthis.before();\n\tif (items.length) {\n\t\tfor (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {\n\t\t\titem = ary[i];\n\t\t\tif (item instanceof Function) {\n\t\t\t\titem(this._dt,this);\n\t\t\t} else if (item.tick) {\n\t\t\t\titem.tick(this._dt,this);\n\t\t\t};\n\t\t};\n\t};\n\tthis._stage = 2;\n\tthis.after();\n\tthis._stage = this._scheduled ? 0 : (-1);\n\treturn this;\n};\n\nTicker.prototype.schedule = function (){\n\tif (!this._scheduled) {\n\t\tthis._scheduled = true;\n\t\tif (this._stage == -1) {\n\t\t\tthis._stage = 0;\n\t\t};\n\t\trequestAnimationFrame(this._ticker);\n\t};\n\treturn this;\n};\n\nTicker.prototype.before = function (){\n\treturn this;\n};\n\nTicker.prototype.after = function (){\n\tif (Imba.TagManager) {\n\t\tImba.TagManager.refresh();\n\t};\n\treturn this;\n};\n\nImba.TICKER = new Ticker();\nImba.SCHEDULERS = [];\n\nImba.ticker = function (){\n\treturn Imba.TICKER;\n};\n\nImba.requestAnimationFrame = function (callback){\n\treturn requestAnimationFrame(callback);\n};\n\nImba.cancelAnimationFrame = function (id){\n\treturn cancelAnimationFrame(id);\n};\n\n// should add an Imba.run / setImmediate that\n// pushes listener onto the tick-queue with times - once\n\nvar commitQueue = 0;\n\nImba.commit = function (params){\n\tcommitQueue++;\n\t// Imba.TagManager.refresh\n\tImba.emit(Imba,'commit',(params != undefined) ? [params] : undefined);\n\tif (--commitQueue == 0) {\n\t\tImba.TagManager && Imba.TagManager.refresh();\n\t};\n\treturn;\n};\n\n/*\n\nInstances of Imba.Scheduler manages when to call `tick()` on their target,\nat a specified framerate or when certain events occur. Root-nodes in your\napplications will usually have a scheduler to make sure they rerender when\nsomething changes. It is also possible to make inner components use their\nown schedulers to control when they render.\n\n@iname scheduler\n\n*/\n\nImba.Scheduler = function Scheduler(target){\n\tvar self = this;\n\tself._id = counter++;\n\tself._target = target;\n\tself._marked = false;\n\tself._active = false;\n\tself._marker = function() { return self.mark(); };\n\tself._ticker = function(e) { return self.tick(e); };\n\t\n\tself._dt = 0;\n\tself._frame = {};\n\tself._scheduled = false;\n\tself._timestamp = 0;\n\tself._ticks = 0;\n\tself._flushes = 0;\n\t\n\tself.onevent = self.onevent.bind(self);\n\tself;\n};\n\nvar counter = 0;\n\nImba.Scheduler.event = function (e){\n\treturn Imba.emit(Imba,'event',e);\n};\n\n/*\n\tCreate a new Imba.Scheduler for specified target\n\t@return {Imba.Scheduler}\n\t*/\n\nImba.Scheduler.prototype.__raf = {watch: 'rafDidSet',name: 'raf'};\nImba.Scheduler.prototype.raf = function(v){ return this._raf; }\nImba.Scheduler.prototype.setRaf = function(v){\n\tvar a = this.raf();\n\tif(v != a) { this._raf = v; }\n\tif(v != a) { this.rafDidSet && this.rafDidSet(v,a,this.__raf) }\n\treturn this;\n};\nImba.Scheduler.prototype.__interval = {watch: 'intervalDidSet',name: 'interval'};\nImba.Scheduler.prototype.interval = function(v){ return this._interval; }\nImba.Scheduler.prototype.setInterval = function(v){\n\tvar a = this.interval();\n\tif(v != a) { this._interval = v; }\n\tif(v != a) { this.intervalDidSet && this.intervalDidSet(v,a,this.__interval) }\n\treturn this;\n};\nImba.Scheduler.prototype.__events = {watch: 'eventsDidSet',name: 'events'};\nImba.Scheduler.prototype.events = function(v){ return this._events; }\nImba.Scheduler.prototype.setEvents = function(v){\n\tvar a = this.events();\n\tif(v != a) { this._events = v; }\n\tif(v != a) { this.eventsDidSet && this.eventsDidSet(v,a,this.__events) }\n\treturn this;\n};\nImba.Scheduler.prototype.marked = function(v){ return this._marked; }\nImba.Scheduler.prototype.setMarked = function(v){ this._marked = v; return this; };\n\nImba.Scheduler.prototype.rafDidSet = function (bool){\n\tif (bool && this._active) this.requestTick();\n\treturn this;\n};\n\nImba.Scheduler.prototype.intervalDidSet = function (time){\n\tclearInterval(this._intervalId);\n\tthis._intervalId = null;\n\tif (time && this._active) {\n\t\tthis._intervalId = setInterval(this.oninterval.bind(this),time);\n\t};\n\treturn this;\n};\n\nImba.Scheduler.prototype.eventsDidSet = function (new$,prev){\n\tif (this._active && new$ && !prev) {\n\t\treturn Imba.listen(Imba,'commit',this,'onevent');\n\t} else if (!(new$) && prev) {\n\t\treturn Imba.unlisten(Imba,'commit',this,'onevent');\n\t};\n};\n\n/*\n\tCheck whether the current scheduler is active or not\n\t@return {bool}\n\t*/\n\nImba.Scheduler.prototype.active = function (){\n\treturn this._active;\n};\n\n/*\n\tDelta time between the two last ticks\n\t@return {Number}\n\t*/\n\nImba.Scheduler.prototype.dt = function (){\n\treturn this._dt;\n};\n\n/*\n\tConfigure the scheduler\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.configure = function (options){\n\tvar v_;\n\tif(options === undefined) options = {};\n\tif (options.raf != undefined) { (this.setRaf(v_ = options.raf),v_) };\n\tif (options.interval != undefined) { (this.setInterval(v_ = options.interval),v_) };\n\tif (options.events != undefined) { (this.setEvents(v_ = options.events),v_) };\n\treturn this;\n};\n\n/*\n\tMark the scheduler as dirty. This will make sure that\n\tthe scheduler calls `target.tick` on the next frame\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.mark = function (){\n\tthis._marked = true;\n\tif (!this._scheduled) {\n\t\tthis.requestTick();\n\t};\n\treturn this;\n};\n\n/*\n\tInstantly trigger target.tick and mark scheduler as clean (not dirty/marked).\n\tThis is called implicitly from tick, but can also be called manually if you\n\treally want to force a tick without waiting for the next frame.\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.flush = function (){\n\tthis._flushes++;\n\tthis._target.tick(this);\n\tthis._marked = false;\n\treturn this;\n};\n\n/*\n\t@fixme this expects raf to run at 60 fps \n\n\tCalled automatically on every frame while the scheduler is active.\n\tIt will only call `target.tick` if the scheduler is marked dirty,\n\tor when according to @fps setting.\n\n\tIf you have set up a scheduler with an fps of 1, tick will still be\n\tcalled every frame, but `target.tick` will only be called once every\n\tsecond, and it will *make sure* each `target.tick` happens in separate\n\tseconds according to Date. So if you have a node that renders a clock\n\tbased on Date.now (or something similar), you can schedule it with 1fps,\n\tnever needing to worry about two ticks happening within the same second.\n\tThe same goes for 4fps, 10fps etc.\n\n\t@protected\n\t@return {self}\n\t*/\n\nImba.Scheduler.prototype.tick = function (delta,ticker){\n\tthis._ticks++;\n\tthis._dt = delta;\n\t\n\tif (ticker) {\n\t\tthis._scheduled = false;\n\t};\n\t\n\tthis.flush();\n\t\n\tif (this._raf && this._active) {\n\t\tthis.requestTick();\n\t};\n\treturn this;\n};\n\nImba.Scheduler.prototype.requestTick = function (){\n\tif (!this._scheduled) {\n\t\tthis._scheduled = true;\n\t\tImba.TICKER.add(this);\n\t};\n\treturn this;\n};\n\n/*\n\tStart the scheduler if it is not already active.\n\t**While active**, the scheduler will override `target.commit`\n\tto do nothing. By default Imba.tag#commit calls render, so\n\tthat rendering is cascaded through to children when rendering\n\ta node. When a scheduler is active (for a node), Imba disables\n\tthis automatic rendering.\n\t*/\n\nImba.Scheduler.prototype.activate = function (immediate){\n\tif(immediate === undefined) immediate = true;\n\tif (!this._active) {\n\t\tthis._active = true;\n\t\tthis._commit = this._target.commit;\n\t\tthis._target.commit = function() { return this; };\n\t\tthis._target && this._target.flag  &&  this._target.flag('scheduled_');\n\t\tImba.SCHEDULERS.push(this);\n\t\t\n\t\tif (this._events) {\n\t\t\tImba.listen(Imba,'commit',this,'onevent');\n\t\t};\n\t\t\n\t\tif (this._interval && !this._intervalId) {\n\t\t\tthis._intervalId = setInterval(this.oninterval.bind(this),this._interval);\n\t\t};\n\t\t\n\t\tif (immediate) {\n\t\t\tthis.tick(0);\n\t\t} else if (this._raf) {\n\t\t\tthis.requestTick();\n\t\t};\n\t};\n\treturn this;\n};\n\n/*\n\tStop the scheduler if it is active.\n\t*/\n\nImba.Scheduler.prototype.deactivate = function (){\n\tif (this._active) {\n\t\tthis._active = false;\n\t\tthis._target.commit = this._commit;\n\t\tlet idx = Imba.SCHEDULERS.indexOf(this);\n\t\tif (idx >= 0) {\n\t\t\tImba.SCHEDULERS.splice(idx,1);\n\t\t};\n\t\t\n\t\tif (this._events) {\n\t\t\tImba.unlisten(Imba,'commit',this,'onevent');\n\t\t};\n\t\t\n\t\tif (this._intervalId) {\n\t\t\tclearInterval(this._intervalId);\n\t\t\tthis._intervalId = null;\n\t\t};\n\t\t\n\t\tthis._target && this._target.unflag  &&  this._target.unflag('scheduled_');\n\t};\n\treturn this;\n};\n\nImba.Scheduler.prototype.track = function (){\n\treturn this._marker;\n};\n\nImba.Scheduler.prototype.oninterval = function (){\n\tthis.tick();\n\tImba.TagManager.refresh();\n\treturn this;\n};\n\nImba.Scheduler.prototype.onevent = function (event){\n\tif (!this._events || this._marked) { return this };\n\t\n\tif (this._events instanceof Function) {\n\t\tif (this._events(event,this)) this.mark();\n\t} else if (this._events instanceof Array) {\n\t\tif (this._events.indexOf((event && event.type) || event) >= 0) {\n\t\t\tthis.mark();\n\t\t};\n\t} else {\n\t\tthis.mark();\n\t};\n\treturn this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/imba/src/imba/scheduler.imba?");

/***/ }),

/***/ "./src/client.imba":
/*!*************************!*\
  !*** ./src/client.imba ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\"), _1 = Imba.createElement;\nvar Router = __webpack_require__(/*! imba-router */ \"./node_modules/imba-router/lib/index.js\").Router;\n\nvar Auth = __webpack_require__(/*! ./request/Auth.imba */ \"./src/request/Auth.imba\").Auth;\n\nvar Header = __webpack_require__(/*! ./layout/Header.imba */ \"./src/layout/Header.imba\").Header;\nvar Home = __webpack_require__(/*! ./pages/Home.imba */ \"./src/pages/Home.imba\").Home;\nvar Login = __webpack_require__(/*! ./pages/Login.imba */ \"./src/pages/Login.imba\").Login;\nvar Form = __webpack_require__(/*! ./pages/Form.imba */ \"./src/pages/Form.imba\").Form;\nvar Dashboard = __webpack_require__(/*! ./pages/Dashboard.imba */ \"./src/pages/Dashboard.imba\").Dashboard;\nvar Footer = __webpack_require__(/*! ./layout/Footer.imba */ \"./src/layout/Footer.imba\").Footer;\n\nImba.extendTag('element', function(tag){\n\ttag.prototype.asset = function (resource){\n\t\tif(resource === undefined) resource = '';\n\t\treturn window.location.pathname + 'build/' + resource;\n\t};\n});\n\nvar App = Imba.defineTag('App', function(tag){\n\ttag.prototype.__isAuthComplete = {'default': false,name: 'isAuthComplete'};\n\ttag.prototype.isAuthComplete = function(v){ return this._isAuthComplete; }\n\ttag.prototype.setIsAuthComplete = function(v){ this._isAuthComplete = v; return this; }\n\ttag.prototype._isAuthComplete = false;\n\t\n\ttag.prototype.build = async function (){\n\t\tthis.setRouter(new Router({mode: 'hash'}));\n\t\tconst auth = await Auth.tryLogin();\n\t\tif (!auth) {\n\t\t\tthis.router().go('/');\n\t\t};\n\t\t\n\t\tthis._isAuthComplete = true;\n\t\treturn Imba.commit();\n\t};\n\t\n\ttag.prototype.render = function (){\n\t\tvar $ = this.$;\n\t\treturn this.$open(0).setChildren(\n\t\t\t(!(this.isAuthComplete())) ? (\n\t\t\t\t($[0] || _1('object',$,0,this).flag('self-centered').setType(\"image/svg+xml\")).setData((this.asset('/loader.svg'))).end()\n\t\t\t) : Imba.static([\n\t\t\t\t($[1] || _1(Header,$,1,this)).end(),\n\t\t\t\t($[2] || _1(Home,$,2,this).setRoute('/')).end(),\n\t\t\t\t($[3] || _1(Login,$,3,this).setRoute('/login')).end(),\n\t\t\t\t($[4] || _1(Form,$,4,this).setRoute('/form')).end(),\n\t\t\t\t($[5] || _1(Dashboard,$,5,this).setRoute('/dashboard')).end(),\n\t\t\t\t($[6] || _1(Footer,$,6,this)).end()\n\t\t\t],2,1)\n\t\t,3).synced();\n\t};\n});\n\nImba.mount((_1(App)).end());\n\n\n//# sourceURL=webpack:///./src/client.imba?");

/***/ }),

/***/ "./src/layout/Footer.imba":
/*!********************************!*\
  !*** ./src/layout/Footer.imba ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar Footer = Imba.defineTag('Footer', function(tag){\n\ttag.prototype.render = function (){\n\t\treturn this.$open(0).synced();\n\t};\n})\nexports.Footer = Footer;\n\n\n//# sourceURL=webpack:///./src/layout/Footer.imba?");

/***/ }),

/***/ "./src/layout/Header.imba":
/*!********************************!*\
  !*** ./src/layout/Header.imba ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar Header = Imba.defineTag('Header', function(tag){\n\ttag.prototype.render = function (){\n\t\treturn this.$open(0).synced();\n\t};\n})\nexports.Header = Header;\n\n\n//# sourceURL=webpack:///./src/layout/Header.imba?");

/***/ }),

/***/ "./src/pages/Dashboard.imba":
/*!**********************************!*\
  !*** ./src/pages/Dashboard.imba ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar Dashboard = Imba.defineTag('Dashboard', function(tag){\n\ttag.prototype.render = function (){\n\t\treturn this.$open(0).setText(\"Dashboard\").synced();\n\t};\n})\nexports.Dashboard = Dashboard;\n\n\n//# sourceURL=webpack:///./src/pages/Dashboard.imba?");

/***/ }),

/***/ "./src/pages/Form.imba":
/*!*****************************!*\
  !*** ./src/pages/Form.imba ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar Form = Imba.defineTag('Form', function(tag){\n\ttag.prototype.render = function (){\n\t\treturn this.$open(0).setText(\"Form\").synced();\n\t};\n})\nexports.Form = Form;\n\n\n//# sourceURL=webpack:///./src/pages/Form.imba?");

/***/ }),

/***/ "./src/pages/Home.imba":
/*!*****************************!*\
  !*** ./src/pages/Home.imba ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar Home = Imba.defineTag('Home', function(tag){\n\ttag.prototype.render = function (){\n\t\treturn this.$open(0).setText(\"Hello World\").synced();\n\t};\n})\nexports.Home = Home;\n\n\n//# sourceURL=webpack:///./src/pages/Home.imba?");

/***/ }),

/***/ "./src/pages/Login.imba":
/*!******************************!*\
  !*** ./src/pages/Login.imba ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nvar Login = Imba.defineTag('Login', function(tag){\n\ttag.prototype.render = function (){\n\t\treturn this.$open(0).setText(\"Login\").synced();\n\t};\n})\nexports.Login = Login;\n\n\n//# sourceURL=webpack:///./src/pages/Login.imba?");

/***/ }),

/***/ "./src/request/Auth.imba":
/*!*******************************!*\
  !*** ./src/request/Auth.imba ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Imba = __webpack_require__(/*! imba */ \"./node_modules/imba/imba.imba\");\nfunction Auth(){ };\n\nAuth.prototype.__session = {'default': {\n\tuser: null\n},name: 'session'};\nAuth.prototype.session = function(v){ return this._session; }\nAuth.prototype.setSession = function(v){ this._session = v; return this; }\nAuth.prototype._session = {\n\tuser: null\n};\n\nAuth.prototype.check = function (){\n\treturn (this._session.user == null) ? false : true;\n};\n\nAuth.prototype.logout = function (){\n\twindow.localStorage._token = null;\n\tthis._session.user = null;\n\t\n\treturn Imba.commit();\n};\n\nAuth.prototype.login = function (user){\n\twindow.localStorage._token = user.token;\n\tthis._session.user = user;\n\t\n\treturn Imba.commit();\n};\n\nAuth.prototype.tryLogin = function (){\n\treturn new Promise(function(resolve) {\n\t\treturn window.setTimeout(function() { return resolve(true); },1000);\n\t});\n};\n\nvar Auth = exports.Auth = new Auth();\n\n// Make sure Auth loaded first\nvar Connect = __webpack_require__(/*! ./Connect.imba */ \"./src/request/Connect.imba\").Connect;\n\n\n//# sourceURL=webpack:///./src/request/Auth.imba?");

/***/ }),

/***/ "./src/request/Connect.imba":
/*!**********************************!*\
  !*** ./src/request/Connect.imba ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Connect(){ };\n\nConnect.prototype.fetch = async function (url){\n\tconst res = await window.fetch(url);\n\ttry {\n\t\treturn await res.json();\n\t} catch (e) {\n\t\treturn {};\n\t};\n};\n\nvar Connect = exports.Connect = new Connect();\n\n\n//# sourceURL=webpack:///./src/request/Connect.imba?");

/***/ })

/******/ });